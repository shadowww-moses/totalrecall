# Предисловие

Я не знал, как законспектировать все эти вещи линейно. Потому что то тут, то там возникали перекрестные ссылки. Поэтому я постарался отдельно в начале описать идеи, не особо снабжая их примерами (или добавлял зарисовки, которые можно назвать примерами чисто условно), а уже в конце сделал раздел целиком из примеров.

Эти примеры я проверил и снабдил подробными комментариями, частично дублирующими теорию и ссылающимися на нее. Комбинаций все равно возможно много, всех не описать. Поэтому я как мог попытался описать базовые случаи, из которых комбинируется все остальное, что может существовать, но не описано. Так что в целом работа с мануалом сводится не к тому, чтобы быстро выцепить что-то конкретное, а к тому, чтобы прочитать все, вникнуть, и смочь самому додуматься до решения искомой задачи.



Для примеров будет использоваться следующая диаграмма:

<img src="img\image-20200502141350264.png" alt="image-20200502141350264" style="zoom:80%;" />

Будем рассматривать отношения

* **Один-к-одному** (1:1) - у пользователя может быть только одна домашняя страница
* **Один-ко-многим** (1:M) - у пользователя может быть много плейлистов. При этом плейлистами нельзя делиться, так что каждый плейлист может принадлежать только одному пользователю
* **Многие-ко-многим** (M:M) - пользователь может быть подписан на много каналов, а у каналов может быть много подписчиков



# Создание контекста

* Подключаем неймспейс `Microsoft.EntityFrameworkCore`

* Создаем класс контекста, наследуясь от `DbContext`

* Настраиваем соединение с БД в методе `OnConfiguring()`. Если начать набирать `override On`, то выскочит удобная подсказка, которая автоматически создаст каркас метода, в который останется дописать желаемые опции:

  <img src="img\image-20200502174548432.png" alt="image-20200502174548432" style="zoom:80%;" />

* В контексте два основных метода - в `OnConfiguring` настраивается сам контекст, а в `OnModelCreating` проводятся настройки для сущностей

* Поскольку БД еще не существует, можно в консольный проект добавить строчки

  ```c#
  var context = new YoucubeContext();
  context.Database.EnsureCreated();
  ```

  и запустить его, чтобы база создалась



# Создание таблиц

Когда классы модели данных оформлены соответствующим образом, нужно создать и применить миграцию, чтобы EF создал таблицы по этой модели, после чего с ними можно будет работать.

Чтобы убедиться, что EF распознал отношения между сущностями именно так, как задумано, можно перед созданием миграции сгенерировать визуальную схему с помощью EF Power Tools и оценить картину.



## 1:1 User → Homepage

Все классы должны иметь поле Id числового типа (например int, long), которые EF использует как первичный ключ:

<img src="img\image-20200502165457669.png" alt="image-20200502165457669" style="zoom:80%;" />

Поле `Homepage` в классе `User` называется **навигационным свойством**. По его типу нему EF поймет, что надо организовать связь с классом `Homepage`. 

Со стороны класса `Homepage` мы задаем поле `int UserId` - это внешний ключ, который свяжется с Id из User. Он должен иметь название в формате *КлассДляСвязиId* и иметь такой же тип.

Если подчиненная сущность может существовать без главной, внешний ключ надо сделать nullable (int?). Пример: самурай и лошадь. У каждого самурая может быть только одна лошадь, и если лошадь выдана самураю, то другие не ней ездить не могут. Однако лошадь может стоять в общем стойле и быть какое-то время бесхозной. В нашем примере предполагается, что если страница есть, значит она принадлежит пользователю. Если нет пользователя, то не может быть и страницы, поэтому поле не nullable.

Чтобы непосредственно работать с таблицей пользователей, нужно добавить в контекст поле типа DbSet, инициализированное типом сущности:

<img src="img\image-20200502171010462.png" alt="image-20200502171010462" style="zoom:80%;" />

Если мы не хотим отдельно работать с домашними страницами в программе, то DbSet для Homepage можем не добавлять.

### Настройка имен для таблиц

Таблицы получают имена по именам DbSet'ов, описанных в контексте. Таблица пользователей, например, получит имя Users.

Поскольку мы решили, что не хотим отдельно работать с домашними страницами в программе и не добавили `DbSet<Homepage>` в контекст, то имя для нее подберется автоматически. И будет оно `Homepage`.

Если нас это не устраивает (а мы хотим, чтобы таблицы имели названия во множественном числе например), мы можем явно указать имя для таблиц, связанных с нашими сущностями. Это делается в методе `OnModelCreating` контекста:

<img src="img\image-20200502171837303.png" alt="image-20200502171837303" style="zoom:80%;" />



## M:M User ↔ Channel

► Для организации между двумя сущностями связи Многие-ко-Многим требуется третья промежуточная сущность:

<img src="img\image-20200503083650396.png" alt="image-20200503083650396" style="zoom:80%;" />

(Выделение памяти под список пропущено для краткости, принято делать это в конструкторе)

Навигационные свойства `Channel` и `User` в промежуточной сущности не являются обязательными, но могут упростить добавление объектов.

► В контексте нужно явно настроить для промежуточной сущности первичный ключ:

<img src="img\image-20200503084727085.png" alt="image-20200503084727085" style="zoom:80%;" />



## 1:M User → Playlist

<img src="img\image-20200507082947795.png" alt="image-20200507082947795" style="zoom:80%;" />

Связь 1:М содержит список в главной сущности и внешний ключ во вторичной. Можно еще добавить навигационное свойство при необходимости. Она нормально определяется EF и проводить дополнительных настроек в методе построения модели не надо.



## Связанные данные

Выборка объекта пользователя не означает выборку связанных с ним объектов, например, каналов и плейлистов. То есть список любимых каналов будет null, если специально не догрузить его. Это относится ко всем типам связей.

Существует несколько способов загрузить связанные данные:

<img src="img\image-20200507140556985.png" alt="image-20200507140556985" style="zoom:80%;" />

#### Жадная загрузка

Поля, содержащие связанные объекты, явно указываются в запросе через методы `Include` и `ThenInclude`:

<img src="img\image-20200507141417510.png" alt="image-20200507141417510" style="zoom:80%;" />

Через Include подключаем "первый уровень связи", в данном случае промежуточную таблицу, подписки, через ThenInclude - второй, уже непосредственно каналы.

Через Include в одном запросе можно выбрать в память сразу несколько связанных объектов. То есть не только избранные каналы, но и плейлисты:

<img src="img\image-20200507142624833.png" alt="image-20200507142624833" style="zoom:80%;" />

Не имеет значения, что ставить сначала - Where или Include.

Include и ThenInclude - это методы DbSet, поэтому их нельзя применять, например, после операторов Find, FirstOrDefault и других, которые возвращают уже конкретный объект.

Include и ThenInclude загружают все связанные данные. Фильтровать их непосредственно в самом Include нельзя (но, к слову, у меня получилось это сделать в разделе проекции). Например, в следующем фрагменте запрос просто не видит поле с каналом, чтобы можно было задать для него какие-то условия:

<img src="img\image-20200507155357870.png" alt="image-20200507155357870" style="zoom:80%;" />

#### Проекция

Если в методе Select использовать поля, содержащие связанные объекты, то они сами загружаются в память:

<img src="img\image-20200507150616074.png" alt="image-20200507150616074" style="zoom:80%;" />

Внешние .Where и .Select возвращают IQueryable, а внутренние - уже IEnumerable, что говорит о том, что в поле Channels анонимного объекта действительно будут данные, а не просто запрос.

Кроме того, в проекции я выполнил фильтрацию каналов, отобрав только только те каналы пользователя, которые предназначены для взрослых.

#### Явная загрузка

Явная загрузка используется, когда главный объект уже находится в памяти и требуется догрузить связанные объекты.

* Для связи типа 1:М догрузка делается методом `Collection`:

<img src="img\image-20200507160502303.png" alt="image-20200507160502303" style="zoom:80%;" />

* Для связи типа 1:1 - методом `Reference`:

  <img src="img\image-20200507161527300.png" alt="image-20200507161527300" style="zoom:80%;" />

* Для связи типа М:М:

  В курсе не было, сам не нашел.

Догрузку можно делать только для одного объекта. Поэтому, если у нас несколько пользователей, которым нужна догрузка, то эффективнее будет сделать новый запрос, чем, например, в цикле делать догрузку явным способом.

Можно догружать не все связанные данные, а по условию:

<img src="img\image-20200507165543880.png" alt="image-20200507165543880" style="zoom:80%;" />

Для связи 1:1 у меня не получилось сделать.

#### Ленивая загрузка

Ленивая загрузка позволяет автоматически загружать связанные данные, когда к ним происходит какое-либо обращение.

<img src="img\image-20200507171422228.png" alt="image-20200507171422228" style="zoom:80%;" />

Чтобы она работала, необходимо выполнить три действия:

* Поставить в сборку с контекстом пакет `Microsoft.EntityFrameworkCore.Proxies`

* Подключить ленивую загрузку при конфигурации контекста:

  <img src="img\image-20200507171725443.png" alt="image-20200507171725443" style="zoom:80%;" />

* Объявить все навигационные свойства во всех сущностях виртуальными:

  <img src="img\image-20200507172223283.png" alt="image-20200507172223283" style="zoom:80%;" />

Ленивая загрузка делает получение связанных данных менее очевидным плюс делает над сущностью обертку, искажая ее тип.

#### Условия к связанным данным

Можно выбирать объекты на основе условий к их связанным данным. При этом не обязательно загружать связанные данные, если они не нужны непосредственно в результате:

<img src="img\image-20200507162819326.png" alt="image-20200507162819326" style="zoom:80%;" />

Выбрали пользователей, у который в домашней странице встречается часть "org".

<img src="img\image-20200507163336345.png" alt="image-20200507163336345" style="zoom:80%;" />

Выбрали пользователей, у который больше двух избранных каналов.





# Работа с таблицами

## EF-функции

В EF встроены некоторые функции, делающие запросы более близкими к SQL-стилю.

Их немного, это `Like` и функции для работы с разницами дат.

<img src="img\image-20200507174900592.png" alt="image-20200507174900592" style="zoom:80%;" />

```c#
context.Users.Where(s => EF.Functions.Like(s.Name, "%ova%")).ToList();
```

<img src="img\image-20200507175249150.png" alt="image-20200507175249150" style="zoom:80%;" />



## Какие SQL-запросы генерирует EF?

Существует несколько способов посмотреть, какие SQL-запросы генерирует EF при работе с БД. Это можно сделать, например, подключив в программу **логгер** или воспользовавшись **профайлером**

### Логгер

Этот метод предназначен для использования логгера в консольном приложении. Для, например, проекта ASP.NET Core логгер подключается иначе.

* Устанавливаем в сборку с EF пакет `Microsoft.Extensions.Logging.Console` 

* Подключаем в файле с контекстом неймспейс `Microsfot.Extensions.Logging`

* Добавляем в класс контекста поле типа `ILoggerFactory`:

  <img src="img\image-20200503125220862.png" alt="image-20200503125220862" style="zoom:80%;" />

* В методе контекста `OnConfiguring` подключаем этот логгер:

  <img src="img\image-20200503125423168.png" alt="image-20200503125423168" style="zoom:80%;" />

Теперь при выполнении программы в консоль будут выводится SQL-запросы, которые формирует EF к базе.

### Профайлер

Профайлер становится доступным после установки SQL Server'а (или, возможно, Management Studio). Вызвать его можно либо через меню пуск, найдя по слову "profiler", либо из Management Studio, меню `Tools > SQL Server Profiler`

* Выбираем сервер:

<img src="img\image-20200504143824548.png" alt="image-20200504143824548" style="zoom:80%;" />

* Выбираем стандартный шаблон:

  <img src="img\image-20200504150858642.png" alt="image-20200504150858642" style="zoom:80%;" />

* Теперь все операции, проходящие на указанном сервере, будут отображаться в профайлере:

  <img src="img\image-20200504151138032.png" alt="image-20200504151138032" style="zoom:80%;" />



## Трекинг объектов

EF отслеживает состояние всех сущностей, с которыми работает. Это называется трекингом. За трекинг отвечает объект `ChangeTracker`, находящийся среди свойств контекста.

Существует **4 метода трекинга**: `Add`, `Update`, `Remove`, `Attach`

В зависимости от того, уже сохранен объект в базу данных или еще нет, методы трекинга устанавливают его в разное состояние:

<img src="img\image-20200503093919503.png" alt="image-20200503093919503" style="zoom:80%;" />

> Если объект еще не сохранен в БД, его Id равен 0

Состояние не является частью отслеживаемого объекта. Оно хранится внутри контекста.

![image-20200506155507456](img\image-20200506155507456.png)



Названия методов трекинга довольно условны. Например, код

```c#
var user = new User(...);
context.Users.Update(user);
context.SaveChanges();
```

вполне успешно добавит нового пользователя в таблицу, хотя метод называется Update, а этот пользователь в таблице еще даже не существует. Поскольку у этого нового объекта Id = 0 и метод Update ставит его в состояние *Added* (как показано на картинке), то EF проведет именно добавление этого объекта в таблицу.

Поэтому следует отталкиваться от понимания того, что это за объект и следовательно в каком состоянии он находится, и исходя из этого уже выбирать метод для установки трекинга этого объекта.

Аналогично

```c#
var Sam = new User("Sam");
context.Users.Add(Sam);
Sam.Name = "Tom";

var Jack = context.Users.Find(5);
Jack.Name = "Frodo";
context.Users.Update(Jack);

context.SaveChanges();
```

не "Добавляет нового пользователя по имени Sam в таблицу Users", а устанавливает объект Sam в состояние "Added" и начинает его отслеживать; не "изменяет имя в объекте Jack на Frodo",  а устанавливает объект Jack в состояние "Modified".

> Вообще, в данном случае вызывать Update для объект Jack не обязательно. Ведь контекст начинает отслеживать этот объект после получения, а поскольку это Connected сценарий, то контекст сам поймет, что объект изменился, когда мы присвоим новое имя. Я специально оставляю этот код и этот комментарий для явного объяснения данной ситуации

А уже при вызове метода SaveChanges контекста, EF обходит граф объектов и выполняет с ними нужные действия относительно БД. Поэтому объект Sam сохранится с именем Tom.

Размышление о работе с сущностями в терминах отслеживания позволяет лучше понимать, что происходит. Например, после сохранения пользователь по имени Tom получит свой Id, который можно будет тут же узнать без дополнительных усилий через объект Sam, поскольку контекст этот объект отслеживает.

Для Disconnected сценариев, когда объекты не отслеживаются контекстом и надо вручную задавать и понимать их состояние, важно помнить, что методы трекинга устанавливают состояние не только для корневого объекта, но и для всех вложенных:

![image-20200504115903568](img\image-20200504115903568.png)



### Отключение трекинга

Автоматический трекинг - удобная функция, позволяющая сделать работу с сущностями проще и эффективнее.  Например, в такой ситуации

```c#
var context = new YoucubeContext();
var user = context.Users.FirstOrDefault(u => u.Username == "ShadowwwMoses");
user.Username = "ShadowMoses";
context.SaveChanges();
```

контекст за счет отслеживания объекта, во-первых, сам поймет, что произошли изменения и переведет объект в состояние modified, а, во-вторых, сгенерирует запрос, который обновит только действительно изменившиеся поля:

```mssql
UPDATE [Users] SET [Username] = @p0
WHERE [Id] = @p1;
```

Однако, автоматический трекинг требует некоторых ресурсов и в некоторых ситуациях (например, в случае Disconnected-сценария) невозможен. Для таких случаев есть несколько способов отключить его:

* В методе OnConfiguring контекста:

  <img src="img\image-20200503103027520.png" alt="image-20200503103027520" style="zoom:80%;" />

* В конструкторе контекста:

  <img src="img\image-20200503103212793.png" alt="image-20200503103212793" style="zoom:80%;" />

  Свойство `ChangeTracker` наследуется от родителя

* Методом `AsNoTracking` при получении объекта с помощью DbSet:

  ```c#
  var context = new YoucubeContext();
  var user = context.Users.AsNoTracking()
      .FirstOrDefault(u => u.Id == 5);
  ```

  В этом случае такую операцию надо проводить для каждого объекта. К тому же, результатом выполнения `AsNoTracking` является `IQueryable`, а значит мы теряем возможность пользоваться методами DbSet, например, `Find`

При отключенном автоматическом трекинге первый пример принимает такую форму:

```c#
var context = new YoucubeContext();
var user = context.Users.AsNoTracking()
    .FirstOrDefault(u => u.Username == "ShadowwwMoses");
user.Username = "ShadowMoses";
context.Update(user);
context.SaveChanges();
```

Во-первых, нам пришлось вручную поставить объекту статус modified, применив метод Update контекста. Во-вторых, EF сгенерировал вот такой SQL-запрос:

```mssql
UPDATE [Users] SET [Age] = @p0, [Browser] = @p1, [County] = @p2, [Username] = @p3
WHERE [Id] = @p4;
```

из которого видно, что перезаписываются все поля, хотя мы изменили всего лишь одно.

### Проверка состояния объекта перед сохранением

Иногда при отладке бывает полезно узнать, в каком состоянии находятся объекты перед сохранением. Это можно сделать, если перед сохранением вызвать метод `DetectChanges`:

```c#
contextPost.ChangeTracker.DetectChanges();
contextPost.SaveChanges();
```

Этот метод вызывается внутри SaveChanges автоматически, но поскольку мы хотим проследить состояние *до* сохранения, то можем вызывать его вручную.

После этого, если поставить на SaveChanges точку останова и добавить в watch свойство `contextPost.ChangeTracker.Entities()` (добавлять надо вручную, метод Entities() не виден, если просто просматривать список свойств), можно увидеть вот такую картину:

<img src="img\image-20200504143230370.png" alt="image-20200504143230370" style="zoom:80%;" />

### Отслеживаемые записи

Все записи, которые в данный момент отслеживает трекер, доступны через его метод `Entries()`:

<img src="img\image-20200509091324786.png" alt="image-20200509091324786" style="zoom:80%;" />



## Connected и Disconnected сценарии

В зависимости от архитектуры приложения может быть два сценария использования контекста:

* **Connected** сценарий, который подразумевает, что извлечение объекта, работа с ним и последующее сохранение производится в пределах одного контекста:

  ```c#
  var context = new YoucubeContext();
  var user = context.Users.FirstOrDefault(u => u.Username == "ShadowwwMoses");
  user.Username = "ShadowMoses";
  context.SaveChanges();
  ```

  Такой сценарий возможен, например, в настольном приложении, когда контекст создается и используется на протяжении длительного времени.

* **Disconnected** сценарий, когда объект извлекается в одном контексте, а сохраняется - в другом. Такой сценарий характерен, например, для WebAPI приложений. Когда запрос приходит на контроллер, создается экземпляр контекста, данные извлекаются и отправляются клиенту, например, для редактирования, а экземпляр контекста уничтожается в конце запроса. Затем от пользователя приходят модифицированные данные, снова создается очередной экземпляр контекста, который ничего не знает о состоянии этих данных, о том, какими они были при извлечении. Для него они являются новыми.

  Имитация данной ситуации:

  ```c#
  var context = new YoucubeContext();
  var user = context.Users.AsNoTracking()
      .FirstOrDefault(u => u.Username == "ShadowwwMoses");
  user.Username = "ShadowMoses";
  using (var newContext = new YoucubeContext())
  {
      newContext.Update(user);
      newContext.SaveChanges();
  }
  ```



## DbSet или Context?

При работе с сущностями можно идти двумя путями:

* Работа через DbSet:

  ```c#
  var user = new User(...);
  context.Users.Add(user);
  ```

* Работа сразу через контекст:

  ```c#
  var user = new User(...);
  context.Add(user);
  ```

### Bulk-операции

Второй вариант имеет преимущество в том, что через контекст можно разом отслеживать сущности разных типов:

```c#
var user = new User(...);
var channel = new Channel(...);
context.AddRange(user, channel);
```

Поскольку типы переменных user и channel известны, EF сам сможет разобраться, как их отслеживать.

DbSet тоже имеет метод `AddRange`, но поскольку DbSet типизирован, можно добавлять только сущности одного типа:

```c#
var Sam = new User(...);
var Tom = new User(...);
var Jack = new User(...);
context.Users.AddRange(Sam, Tom, Jack);
```

Метод `AddRange` относится к **Bulk-операциям** и позволяет добиться лучшей производительности, чем при множественном вызове методов `Add`. Он также позволяет добавить список объектов:

```c#
var users = new List<User>()
{
    new User() { Username = "Tom" },
    new User() { Username = "Sam" },
    new User() { Username = "Jack" }
};
context.Users.AddRange(users);
context.SaveChanges();
```

Однако производительность повышается только если добавляется 4 и больше элементов, иначе она даже падает.

Методы `Update`, `Remove` и `Attach` тоже имеют Range-версии.



## Вычисление запроса

<img src="img\image-20200503110254759.png" alt="image-20200503110254759"  />

Этапы оформления запроса и получения данных разделены. Это означает, что при написании, например, вот такого кода:

```c#
var users = context.Users.Where(u => u.County == "Russia");
```

в переменной users пока еще нет никаких данных. Это позволяет формировать запросы, постепенно дописывая условия или другие операции:

```c#
var users = context.Users.Where(u => u.County == "Russia");
users = users.Where(u => u.Age > 30);
var data = users.ToList();
```

Здесь только в последней строчке запускается процесс получения данных, потому что к запросу применяется метод `ToList`.

Вот список методов, которые инициируют выполнение запроса:

<img src="img\image-20200503112028181.png" alt="image-20200503112028181" style="zoom:80%;" />



Кроме этого, попытка обойти элементы тоже инициирует выполнение запроса:

```c#
var users = context.Users.Where(u => u.County == "Russia");
foreach (var user in users) 
{ 
    user.Country = "Russian Federation";
}
context.SaveChanges();
```

Этот вариант характеризуется тем, что соединение с БД будет оставаться открытым на протяжении всего времени, пока крутится цикл. И если в нем находятся тяжелые операции, то и соединение будет висеть очень долго, а нужно стараться минимизировать это время.

Поэтому хорошей практикой считается выполнение запроса и получение данных в память *до* их обхода:

```c#
var users = context.Users.Where(u => u.County == "Russia").ToList();
foreach (var user in users) 
{ 
    user.Country = "Russian Federation";
}
context.SaveChanges();
```



# Shadow Properties

SP - это техника, позволяющая хранить в базе данных дополнительную информацию о сущности. В классе самой сущности поля для этой информации создавать не нужно, но при этом можно использовать эти поля в запросах. Это позволяет разгрузить сущности от некоторых вещей, которые могут не иметь отношения к бизнес-логике, но при этом хранят информацию, полезную в каких-то случаях.

<img src="img\image-20200508110153477.png" alt="image-20200508110153477" style="zoom:80%;" />

## Создание SP

SP объявляются в методе `OnModelCreating` контекста:

<img src="img\image-20200508110753748.png" alt="image-20200508110753748" style="zoom:80%;" />

Если нужно создать одинаковые SP для множества сущностей, можно сделать это в цикле:

<img src="img\image-20200508125233278.png" alt="image-20200508125233278" style="zoom:80%;" />

## Запись и чтение SP

Запись:

<img src="img\image-20200508134824830.png" alt="image-20200508134824830" style="zoom:80%;" />

А с помощью проекции можно выбрать значение SP:

<img src="img\image-20200508142204248.png" alt="image-20200508142204248" style="zoom:80%;" />

## Использование SP в запросах

<img src="img\image-20200508141436211.png" alt="image-20200508141436211" style="zoom:80%;" />



## SP и перегрузка SaveChanges()

Интересный пример, позволяющий при сохранении объектов заполнять их SP времени создания и последнего доступа:

<img src="img\image-20200508141036962.png" alt="image-20200508141036962" style="zoom:80%;" />

# Entity и Entry

**Entity** - это сущность, тип. Поэтому обычно используется в разных конфигурационных методах:

<img src="img\image-20200509090932633.png" alt="image-20200509090932633" style="zoom:80%;" />

**Entry** - это экземпляр сущности. По экземпляру можно через контекст добраться до SP этой сущности, а также, например, контролировать состояние каждого экземпляра вручную:

<img src="img\image-20200509084231112.png" alt="image-20200509084231112" style="zoom:80%;" />

В этом примере показано как управлять состоянием отдельного экземпляра сущности вручную. В данном случае это нужно, потому что из-за disconnected-сценария мы должны как-то самостоятельно сообщить контексту, что именно мы изменили. 

Если выполнить `contextPost.Playlists.Update(playlist)` то контекст обновит все плейлисты пользователя и даже самого пользователя. Поэтому мы явно указываем для отдельно взятой цитаты состояние Modified, чтобы избежать лишних операций обновления.



# ???Owned Types

> Возникла проблема с созданием OT. Решить пока не удалось.
>
> The type 'Uzername' cannot be marked as owned because a non-owned entity type with the same name already exists.
>
> Пробовал менять имя поля, чтобы оно отличалось от имени типа, не помогло. Гугление ответа не дало

Есть категория объектов, которые не имеют идентификатора (ключа). В терминах DDD они называются Value Objects. 

Однако в EF все сущности должны иметь ключ. Поэтому для решения этого вопроса и хранения такой категории объектов существуют Owned Types.

## Создание OT

* Создаем обычный класс:

  <img src="img\image-20200508144643851.png" alt="image-20200508144643851" style="zoom:80%;" />

  Обязательно должен присутствовать конструктор без параметров. Можно сделать его приватным, это неважно, потому что EF получает его через рефлексию.

* Добавляем поле этого типа в желаемый класс:

  <img src="img\image-20200508145432350.png" alt="image-20200508145432350" style="zoom:80%;" />

* В `OnModelCreating` контекста явно указываем, что это не сущность, а Owned Type:

  



# Тестирование EF

* Добавляем в решение проект с типом тест. В данном примере используется `MsTest`

  <img src="img\image-20200509091649278.png" alt="image-20200509091649278" style="zoom:80%;" />

* Настраиваем ссылки на сборки, типы которых будем тестировать

* Устанавливать пакеты EFCore в сборку с тестами не нужно

* Меняем в контексте имя рабочей базы на тестовую. Достаточно просто изменить имя, а база потом создастся, если ее не существует

## Тестирование настоящей БД

<img src="img\image-20200509092014962.png" alt="image-20200509092014962" style="zoom:80%;" />

Здесь используется реальная база данных, поэтому тест будет выполняться долго, потому что много времени будет тратиться на удаление и создание БД.

## Запуск тестов

Окно со списком тестов открывается через главное меню `Test > Test Explorer`

<img src="img\image-20200509092554351.png" alt="image-20200509092554351" style="zoom:80%;" />

После выполнения теста можно посмотреть полный список операций, который при этом выполнился, нажав на `Open additional output for this result`

## InMemory тестирование

Позволяет значительно ускорить выполнение тестов, хотя имеет некоторые отличия по сравнению с реальной базой. Например, Id при сохранении объектов формируются по-другому.

* Устанавливаем пакет `Microsoft.EntityFrameworkCore.InMemory`

* Вносим изменения в контекст:

  <img src="img\image-20200509093035645.png" alt="image-20200509093035645" style="zoom:80%;" />

  Смысл в том, что если мы теперь не передадим в конструктор контекста опции создания, то сработает условие в методе `OnConfiguring` и произойдет настройка на обычную базу. Если передадим, то в этих опциях сможем указать тестовую базу и настройка пойдет на нее.

* В самом тесте теперь передаем в конструктор контекста соответствующие настройки (CanInsertUser в данном случае это имя, которая получит БД в памяти):

  <img src="img\image-20200509093605084.png" alt="image-20200509093605084" style="zoom:80%;" />



# Примеры

## Многие-ко-многим

### Добавление

#### Через промежуточную сущность

* Пользователь и канал уже существуют. Добавление делаем через передачу ключей в новый объект промежуточной сущности:

  <img src="img\image-20200504103704878.png" alt="image-20200504103704878" style="zoom:80%;" />

  Мы явно создаем объект связующей сущности `Subscription`, заполняем его и, поскольку DbSet для этой сущности отсутствует, пользуемся для добавления методом контекста.

* Пользователь и канал уже существуют. Добавление делаем через передачу объектов пользователя и канала в промежуточную сущность:

  <img src="img\image-20200504103850634.png" alt="image-20200504103850634" style="zoom:80%;" />

  Делаем то же самое, только вместо ключей указываем объекты. Этот вариант возможен, только если в промежуточной сущности есть навигационные свойства.

  Для этого примера возможен **Disconnected** сценарий:

  <img src="img\image-20200504121757597.png" alt="image-20200504121757597" style="zoom:80%;" />

  Интерес вызывает то, что если вместо метода Attach использовать Add, то будет ошибка, потому что, как было описано в разделе про трекинг объектов, метод задает состояние для всего графа объектов, а не только для корня. Хотя нам действительно надо добавить новый, еще не существующий, объект подписки в таблицу, но при использовании Add объекты пользователя и канала тоже получат состояние *Added* и EF при сохранении изменений попробует их добавить в таблицы. Но поскольку эти объекты уже существуют, возникнет ошибка.

  Поэтому мы используем метод Attach, который, как опять же писалось в разделе про трекинг, поставит объекту подписки статус *Added*, потому что он определится как новый за счет того, что у него еще нет значений ключа, а объекты пользователя и канала получат статус *Unchanged*, потому что это стандартный статус при методе Attach. Таким образом, новая подписка вставится в таблицу, а пользователь и канал останутся нетронутыми из-за статуса Unchanged, и операция завершится как надо.

* Ни пользователь, ни канал не существуют. Добавление делаем через объекты, используя промежуточную сущность:

  <img src="img\image-20200504105738141.png" alt="image-20200504105738141" style="zoom:80%;" />

  В данном случае EF автоматически сначала добавит новых пользователя и канал в таблицы `Users` и `Channels`, получит их Id, а затем свяжет их в промежуточной таблице. Disconnected сценарий здесь рассматривать нет смысла, потому что все объекты новые, следовательно добавляются через Add и никаких тонкостей нет.

#### Через один из объектов

Промежуточную сущность не обязательно явно добавлять в контекст. Можно добавить ее через объект какой-либо стороны отношения М:М:

* Пользователь и канал существуют. Добавление делаем через объект пользователя с помощью ключа:

  <img src="img\image-20200504110619717.png" alt="image-20200504110619717" style="zoom:80%;" />

  Если до этого мы создавали объект `Subscription` и самостоятельно добавляли его в таблицу с помощью контекста, то в этом примере демонстрируется как добавить его с помощью объекта пользователя. В таком случае для Subscription не нужно указывать объект пользователя - он сам поймет, с каким пользователем идет операция.

  Касаемо формирования объекта `Subscription`, можно использовать те же подходы, что и в предыдущих примерах - например, давать не Id канала, а объект; подписывать не на существующий канал, а на только что созданный, и т.д. За счет того, что контекст после нахождения объекта начинает его отслеживать, после добавления подписки не требуется никаких дополнительных действий, кроме вызова сохранения.

  А вот пара примеров, демонстрирующих **disconnected** сценарий:

  

  <img src="img\image-20200504141157337.png" alt="image-20200504141157337" style="zoom:80%;" />

  

<img src="img\image-20200504141230632.png" alt="image-20200504141230632" style="zoom:80%;" />

* Подписка сразу на несколько каналов (придумал сам, может есть и другой способ):

  <img src="img\image-20200504160916690.png" alt="image-20200504160916690" style="zoom:80%;" />

### Выборка

* Выбор всех любимых каналов пользователя:

  <img src="img\image-20200507083539682.png" alt="image-20200507083539682" style="zoom:80%;" />

  <img src="img\image-20200508080639714.png" alt="image-20200508080639714" style="zoom:80%;" />



### Изменение

Изменение проще всего делается удалением записи из связующей таблицы и добавлением новой:

<img src="img\image-20200508084142913.png" alt="image-20200508084142913" style="zoom:80%;" />

Я попытался найти объект подписки через пользователя и заменить в ней канал, но возникла ошибка типа нельзя заменять значение первичного ключа. Поэтому думаю просто удалить подписку и добавить правильную самый оптимальный вариант.

### Удаление

* Можно производить удаление подписки непосредственно:

<img src="img\image-20200508081320702.png" alt="image-20200508081320702" style="zoom:80%;" />

Или

<img src="img\image-20200508090659526.png" alt="image-20200508090659526" style="zoom:80%;" />

* Можно производить удаление через объект пользователя:

  <img src="img\image-20200508092258865.png" alt="image-20200508092258865" style="zoom:80%;" />

  В случае Disconnected сценария нужно еще дополнительно явно удалить сущность через контекст, потому что объект пользователя не отслеживается и удаления только из его внутреннего списка будет недостаточно:

  <img src="img\image-20200508092722188.png" alt="image-20200508092722188" style="zoom:80%;" />

## Один-ко-многим

1:М это, по сути, частный случай М:М, поэтому нет смысла писать много примеров. Если жизнь заставит, напишу. Пока оставлю только на добавление.

### Добавление

Добавление делается очень похожим на М:М образом.

* Добавление нового плейлиста существующему пользователю:

<img src="img\image-20200507090920201.png" alt="image-20200507090920201" style="zoom:80%;" />

<img src="img\image-20200507090904633.png" alt="image-20200507090904633" style="zoom:80%;" />

Самый простой способ - добавить плейлист напрямую, снабдив его внешним ключом к пользователю. Поскольку для плейлистов нет DbSet, добавляем через контекст:

<img src="img\image-20200507091611740.png" alt="image-20200507091611740" style="zoom:80%;" />

### Обновление

<img src="img\image-20200509084231112.png" alt="image-20200509084231112" style="zoom:80%;" />

В этом примере показано как управлять состоянием отдельного экземпляра сущности вручную. В данном случае это нужно, потому что из-за disconnected-сценария мы должны как-то самостоятельно сообщить контексту, что именно мы изменили. 

Если выполнить `contextPost.Playlists.Update(playlist)` то контекст обновит все плейлисты пользователя и даже самого пользователя. Поэтому мы явно указываем для отдельно взятой цитаты состояние Modified, чтобы избежать лишних операций обновления.



## Один-к-одному

Все методы работы в разных типах связей пересекаются и похожи. Тут оставляю только что-то более-менее интересное конкретно для 1:1.

### Выборка

* Можно выбирать объекты на основе условий к их связанным данным. При этом не обязательно загружать связанные данные, если они не нужны непосредственно в результате:

  <img src="img\image-20200507162501006.png" alt="image-20200507162501006" style="zoom:80%;" />

### Обновление

В обновлении можно действительно обновить адрес домашней страницы, а можно удалить существующую и добавить новую. В данном случае интерес вызывает то, как EF ведет себя в разных случаях.

* Если пользователь отслеживается, то при присваивании новой домашней страницы старая сначала автоматически удалится:

<img src="img\image-20200508100241576.png" alt="image-20200508100241576" style="zoom:80%;" />

* Если пользователь не отслеживается, то нужно либо действительно просто изменить данные в существующем объекте (отдельного DbSet для домашних страниц нет):

  <img src="img\image-20200508101515351.png" alt="image-20200508101515351" style="zoom:80%;" />

  либо самостоятельно пометить на удаление старую страницу перед установкой новой:

  <img src="img\image-20200508102124428.png" alt="image-20200508102124428" style="zoom:80%;" />