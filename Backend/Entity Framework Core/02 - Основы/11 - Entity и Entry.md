# Entity и Entry

**Entity** - это сущность, тип. Поэтому обычно используется в разных конфигурационных методах:

<img src="img\image-20200509090932633.png" alt="image-20200509090932633" style="zoom:80%;" />

**Entry** - это экземпляр сущности. По экземпляру можно через контекст добраться до SP этой сущности, а также, например, контролировать состояние каждого экземпляра вручную:

<img src="img\image-20200509084231112.png" alt="image-20200509084231112" style="zoom:80%;" />

В этом примере показано как управлять состоянием отдельного экземпляра сущности вручную. В данном случае это нужно, потому что из-за disconnected-сценария мы должны как-то самостоятельно сообщить контексту, что именно мы изменили. 

Если выполнить `contextPost.Playlists.Update(playlist)` то контекст обновит все плейлисты пользователя и даже самого пользователя. Поэтому мы явно указываем для отдельно взятой цитаты состояние Modified, чтобы избежать лишних операций обновления.



# ???Owned Types

> Возникла проблема с созданием OT. Решить пока не удалось.
>
> The type 'Uzername' cannot be marked as owned because a non-owned entity type with the same name already exists.
>
> Пробовал менять имя поля, чтобы оно отличалось от имени типа, не помогло. Гугление ответа не дало

Есть категория объектов, которые не имеют идентификатора (ключа). В терминах DDD они называются Value Objects. 

Однако в EF все сущности должны иметь ключ. Поэтому для решения этого вопроса и хранения такой категории объектов существуют Owned Types.

## Создание OT

* Создаем обычный класс:

  <img src="img\image-20200508144643851.png" alt="image-20200508144643851" style="zoom:80%;" />

  Обязательно должен присутствовать конструктор без параметров. Можно сделать его приватным, это неважно, потому что EF получает его через рефлексию.

* Добавляем поле этого типа в желаемый класс:

  <img src="img\image-20200508145432350.png" alt="image-20200508145432350" style="zoom:80%;" />

* В `OnModelCreating` контекста явно указываем, что это не сущность, а Owned Type:

  



# Тестирование EF

* Добавляем в решение проект с типом тест. В данном примере используется `MsTest`

  <img src="img\image-20200509091649278.png" alt="image-20200509091649278" style="zoom:80%;" />

* Настраиваем ссылки на сборки, типы которых будем тестировать

* Устанавливать пакеты EFCore в сборку с тестами не нужно

* Меняем в контексте имя рабочей базы на тестовую. Достаточно просто изменить имя, а база потом создастся, если ее не существует

## Тестирование настоящей БД

<img src="img\image-20200509092014962.png" alt="image-20200509092014962" style="zoom:80%;" />

Здесь используется реальная база данных, поэтому тест будет выполняться долго, потому что много времени будет тратиться на удаление и создание БД.

## Запуск тестов

Окно со списком тестов открывается через главное меню `Test > Test Explorer`

<img src="img\image-20200509092554351.png" alt="image-20200509092554351" style="zoom:80%;" />

После выполнения теста можно посмотреть полный список операций, который при этом выполнился, нажав на `Open additional output for this result`

## InMemory тестирование

Позволяет значительно ускорить выполнение тестов, хотя имеет некоторые отличия по сравнению с реальной базой. Например, Id при сохранении объектов формируются по-другому.

* Устанавливаем пакет `Microsoft.EntityFrameworkCore.InMemory`

* Вносим изменения в контекст:

  <img src="img\image-20200509093035645.png" alt="image-20200509093035645" style="zoom:80%;" />

  Смысл в том, что если мы теперь не передадим в конструктор контекста опции создания, то сработает условие в методе `OnConfiguring` и произойдет настройка на обычную базу. Если передадим, то в этих опциях сможем указать тестовую базу и настройка пойдет на нее.

* В самом тесте теперь передаем в конструктор контекста соответствующие настройки (CanInsertUser в данном случае это имя, которая получит БД в памяти):

  <img src="img\image-20200509093605084.png" alt="image-20200509093605084" style="zoom:80%;" />



# Примеры

## Многие-ко-многим

### Добавление

#### Через промежуточную сущность

* Пользователь и канал уже существуют. Добавление делаем через передачу ключей в новый объект промежуточной сущности:

  <img src="img\image-20200504103704878.png" alt="image-20200504103704878" style="zoom:80%;" />

  Мы явно создаем объект связующей сущности `Subscription`, заполняем его и, поскольку DbSet для этой сущности отсутствует, пользуемся для добавления методом контекста.

* Пользователь и канал уже существуют. Добавление делаем через передачу объектов пользователя и канала в промежуточную сущность:

  <img src="img\image-20200504103850634.png" alt="image-20200504103850634" style="zoom:80%;" />

  Делаем то же самое, только вместо ключей указываем объекты. Этот вариант возможен, только если в промежуточной сущности есть навигационные свойства.

  Для этого примера возможен **Disconnected** сценарий:

  <img src="img\image-20200504121757597.png" alt="image-20200504121757597" style="zoom:80%;" />

  Интерес вызывает то, что если вместо метода Attach использовать Add, то будет ошибка, потому что, как было описано в разделе про трекинг объектов, метод задает состояние для всего графа объектов, а не только для корня. Хотя нам действительно надо добавить новый, еще не существующий, объект подписки в таблицу, но при использовании Add объекты пользователя и канала тоже получат состояние *Added* и EF при сохранении изменений попробует их добавить в таблицы. Но поскольку эти объекты уже существуют, возникнет ошибка.

  Поэтому мы используем метод Attach, который, как опять же писалось в разделе про трекинг, поставит объекту подписки статус *Added*, потому что он определится как новый за счет того, что у него еще нет значений ключа, а объекты пользователя и канала получат статус *Unchanged*, потому что это стандартный статус при методе Attach. Таким образом, новая подписка вставится в таблицу, а пользователь и канал останутся нетронутыми из-за статуса Unchanged, и операция завершится как надо.

* Ни пользователь, ни канал не существуют. Добавление делаем через объекты, используя промежуточную сущность:

  <img src="img\image-20200504105738141.png" alt="image-20200504105738141" style="zoom:80%;" />

  В данном случае EF автоматически сначала добавит новых пользователя и канал в таблицы `Users` и `Channels`, получит их Id, а затем свяжет их в промежуточной таблице. Disconnected сценарий здесь рассматривать нет смысла, потому что все объекты новые, следовательно добавляются через Add и никаких тонкостей нет.

#### Через один из объектов

Промежуточную сущность не обязательно явно добавлять в контекст. Можно добавить ее через объект какой-либо стороны отношения М:М:

* Пользователь и канал существуют. Добавление делаем через объект пользователя с помощью ключа:

  <img src="img\image-20200504110619717.png" alt="image-20200504110619717" style="zoom:80%;" />

  Если до этого мы создавали объект `Subscription` и самостоятельно добавляли его в таблицу с помощью контекста, то в этом примере демонстрируется как добавить его с помощью объекта пользователя. В таком случае для Subscription не нужно указывать объект пользователя - он сам поймет, с каким пользователем идет операция.

  Касаемо формирования объекта `Subscription`, можно использовать те же подходы, что и в предыдущих примерах - например, давать не Id канала, а объект; подписывать не на существующий канал, а на только что созданный, и т.д. За счет того, что контекст после нахождения объекта начинает его отслеживать, после добавления подписки не требуется никаких дополнительных действий, кроме вызова сохранения.

  А вот пара примеров, демонстрирующих **disconnected** сценарий:

  

  <img src="img\image-20200504141157337.png" alt="image-20200504141157337" style="zoom:80%;" />

  

<img src="img\image-20200504141230632.png" alt="image-20200504141230632" style="zoom:80%;" />

* Подписка сразу на несколько каналов (придумал сам, может есть и другой способ):

  <img src="img\image-20200504160916690.png" alt="image-20200504160916690" style="zoom:80%;" />

### Выборка

* Выбор всех любимых каналов пользователя:

  <img src="img\image-20200507083539682.png" alt="image-20200507083539682" style="zoom:80%;" />

  <img src="img\image-20200508080639714.png" alt="image-20200508080639714" style="zoom:80%;" />



### Изменение

Изменение проще всего делается удалением записи из связующей таблицы и добавлением новой:

<img src="img\image-20200508084142913.png" alt="image-20200508084142913" style="zoom:80%;" />

Я попытался найти объект подписки через пользователя и заменить в ней канал, но возникла ошибка типа нельзя заменять значение первичного ключа. Поэтому думаю просто удалить подписку и добавить правильную самый оптимальный вариант.

### Удаление

* Можно производить удаление подписки непосредственно:

<img src="img\image-20200508081320702.png" alt="image-20200508081320702" style="zoom:80%;" />

Или

<img src="img\image-20200508090659526.png" alt="image-20200508090659526" style="zoom:80%;" />

* Можно производить удаление через объект пользователя:

  <img src="img\image-20200508092258865.png" alt="image-20200508092258865" style="zoom:80%;" />

  В случае Disconnected сценария нужно еще дополнительно явно удалить сущность через контекст, потому что объект пользователя не отслеживается и удаления только из его внутреннего списка будет недостаточно:

  <img src="img\image-20200508092722188.png" alt="image-20200508092722188" style="zoom:80%;" />

## Один-ко-многим

1:М это, по сути, частный случай М:М, поэтому нет смысла писать много примеров. Если жизнь заставит, напишу. Пока оставлю только на добавление.

### Добавление

Добавление делается очень похожим на М:М образом.

* Добавление нового плейлиста существующему пользователю:

<img src="img\image-20200507090920201.png" alt="image-20200507090920201" style="zoom:80%;" />

<img src="img\image-20200507090904633.png" alt="image-20200507090904633" style="zoom:80%;" />

Самый простой способ - добавить плейлист напрямую, снабдив его внешним ключом к пользователю. Поскольку для плейлистов нет DbSet, добавляем через контекст:

<img src="img\image-20200507091611740.png" alt="image-20200507091611740" style="zoom:80%;" />

### Обновление

<img src="img\image-20200509084231112.png" alt="image-20200509084231112" style="zoom:80%;" />

В этом примере показано как управлять состоянием отдельного экземпляра сущности вручную. В данном случае это нужно, потому что из-за disconnected-сценария мы должны как-то самостоятельно сообщить контексту, что именно мы изменили. 

Если выполнить `contextPost.Playlists.Update(playlist)` то контекст обновит все плейлисты пользователя и даже самого пользователя. Поэтому мы явно указываем для отдельно взятой цитаты состояние Modified, чтобы избежать лишних операций обновления.



## Один-к-одному

Все методы работы в разных типах связей пересекаются и похожи. Тут оставляю только что-то более-менее интересное конкретно для 1:1.

### Выборка

* Можно выбирать объекты на основе условий к их связанным данным. При этом не обязательно загружать связанные данные, если они не нужны непосредственно в результате:

  <img src="img\image-20200507162501006.png" alt="image-20200507162501006" style="zoom:80%;" />

### Обновление

В обновлении можно действительно обновить адрес домашней страницы, а можно удалить существующую и добавить новую. В данном случае интерес вызывает то, как EF ведет себя в разных случаях.

* Если пользователь отслеживается, то при присваивании новой домашней страницы старая сначала автоматически удалится:

<img src="img\image-20200508100241576.png" alt="image-20200508100241576" style="zoom:80%;" />

* Если пользователь не отслеживается, то нужно либо действительно просто изменить данные в существующем объекте (отдельного DbSet для домашних страниц нет):

  <img src="img\image-20200508101515351.png" alt="image-20200508101515351" style="zoom:80%;" />

  либо самостоятельно пометить на удаление старую страницу перед установкой новой:

  <img src="img\image-20200508102124428.png" alt="image-20200508102124428" style="zoom:80%;" />