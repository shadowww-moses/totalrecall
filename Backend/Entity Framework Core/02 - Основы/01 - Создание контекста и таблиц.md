# Предисловие

Я не знал, как законспектировать все эти вещи линейно. Потому что то тут, то там возникали перекрестные ссылки. Поэтому я постарался отдельно в начале описать идеи, не особо снабжая их примерами (или добавлял зарисовки, которые можно назвать примерами чисто условно), а уже в конце сделал раздел целиком из примеров.

Эти примеры я проверил и снабдил подробными комментариями, частично дублирующими теорию и ссылающимися на нее. Комбинаций все равно возможно много, всех не описать. Поэтому я как мог попытался описать базовые случаи, из которых комбинируется все остальное, что может существовать, но не описано. Так что в целом работа с мануалом сводится не к тому, чтобы быстро выцепить что-то конкретное, а к тому, чтобы прочитать все, вникнуть, и смочь самому додуматься до решения искомой задачи.

Для примеров будет использоваться следующая диаграмма:

<img src="img\image-20200502141350264.png" alt="image-20200502141350264" style="zoom:80%;" />

Будем рассматривать отношения

* **Один-к-одному** (1:1) - у пользователя может быть только одна домашняя страница
* **Один-ко-многим** (1:M) - у пользователя может быть много плейлистов. При этом плейлистами нельзя делиться, так что каждый плейлист может принадлежать только одному пользователю
* **Многие-ко-многим** (M:M) - пользователь может быть подписан на много каналов, а у каналов может быть много подписчиков



# Создание контекста

БД пока не существует.

* Подключаем неймспейс `Microsoft.EntityFrameworkCore`

* Создаем класс контекста, наследуясь от `DbContext`

* Настраиваем соединение с БД в методе `OnConfiguring()`. Если начать набирать `override On`, то выскочит удобная подсказка, которая автоматически создаст каркас метода, в который останется дописать желаемые опции:

  <img src="img\image-20200502174548432.png" alt="image-20200502174548432" style="zoom:80%;" />

* В контексте два основных метода - в `OnConfiguring` настраивается сам контекст, а в `OnModelCreating` проводятся настройки для сущностей

* Поскольку БД еще не существует, можно в консольный проект добавить строчки

  ```c#
  var context = new YoucubeContext();
  context.Database.EnsureCreated();
  ```

  и запустить его, чтобы база создалась



# Создание таблиц

Когда классы модели данных оформлены соответствующим образом, нужно создать и применить миграцию, чтобы EF создал таблицы по этой модели, после чего с ними можно будет работать.

Чтобы убедиться, что EF распознал отношения между сущностями именно так, как задумано, можно перед созданием миграции сгенерировать визуальную схему с помощью `EF Power Tools` (описано в конспекте "Установка и настройка") и оценить картину.



## 1:1 User → Homepage

► Все классы должны иметь поле `Id` числового типа (например int, long), которые EF использует как первичный ключ:

<img src="img\image-20200502165457669.png" alt="image-20200502165457669" style="zoom:80%;" />

Поле `Homepage` в классе `User` называется **навигационным свойством**. По его типу нему EF поймет, что надо организовать связь с классом `Homepage`. 

Со стороны класса `Homepage` мы задаем поле `int UserId` - это внешний ключ, который свяжется с Id из User. Он должен иметь название в формате *КлассДляСвязиId* и иметь такой же тип.

► Если подчиненная сущность может существовать без главной, внешний ключ надо сделать nullable (int?). Пример: самурай и лошадь. У каждого самурая может быть только одна лошадь, и если лошадь выдана самураю, то другие на ней ездить не могут. Однако лошадь может стоять в общем стойле и быть какое-то время бесхозной. В нашем примере предполагается, что если страница есть, значит она принадлежит пользователю. Если нет пользователя, то не может быть и страницы, поэтому поле не nullable.

► Чтобы непосредственно работать с таблицей пользователей, нужно добавить в контекст поле типа DbSet, инициализированное типом сущности:

<img src="img\image-20200502171010462.png" alt="image-20200502171010462" style="zoom:80%;" />

Если мы не хотим отдельно работать с домашними страницами в программе, то DbSet для Homepage можем не добавлять.

### Настройка имен для таблиц

Таблицы получают имена по именам DbSet'ов, описанных в контексте. Таблица пользователей, например, получит имя Users.

Поскольку мы решили, что не хотим отдельно работать с домашними страницами и не добавили `DbSet<Homepage>` в контекст, то имя для нее подберется автоматически - `Homepage`.

Если нас это не устраивает (а мы хотим, чтобы таблицы имели названия во множественном числе например), мы можем явно указать имя для таблиц, связанных с нашими сущностями. Это делается в методе `OnModelCreating` контекста:

<img src="img\image-20200502171837303.png" alt="image-20200502171837303" style="zoom:80%;" />



## 1:M User → Playlist

<img src="img\image-20200507082947795.png" alt="image-20200507082947795" style="zoom:80%;" />

Связь 1:М содержит список в главной сущности и внешний ключ в зависимой. Можно еще добавить навигационное свойство при необходимости. Она нормально определяется EF и проводить дополнительных настроек в методе построения модели не надо.



## M:M User ↔ Channel

► Для организации между двумя сущностями связи Многие-ко-Многим требуется третья промежуточная сущность:

<img src="img\image-20200503083650396.png" alt="image-20200503083650396" style="zoom:80%;" />

(Выделение памяти под список пропущено для краткости, принято делать это в конструкторе)

Навигационные свойства `Channel` и `User` в промежуточной сущности не являются обязательными, но могут упростить добавление объектов.

► В контексте нужно явно настроить для промежуточной сущности первичный ключ:

<img src="img\image-20200503084727085.png" alt="image-20200503084727085" style="zoom:80%;" />



# Связанные данные

Выборка объекта пользователя не означает выборку связанных с ним объектов, например, каналов и плейлистов. То есть список любимых каналов будет null, если специально не догрузить его. Это относится ко всем типам связей.

Существует несколько способов загрузить связанные данные:

<img src="img\image-20200507140556985.png" alt="image-20200507140556985" style="zoom:80%;" />

### Жадная загрузка

Поля, содержащие связанные объекты, явно указываются в запросе через методы `Include` и `ThenInclude`:

<img src="img\image-20200507141417510.png" alt="image-20200507141417510" style="zoom:80%;" />

Через Include подключаем "первый уровень связи", в данном случае промежуточную таблицу, подписки, через ThenInclude - второй, уже непосредственно каналы.

Через Include в одном запросе можно выбрать в память сразу несколько связанных объектов. То есть не только избранные каналы, но и плейлисты:

<img src="img\image-20200507142624833.png" alt="image-20200507142624833" style="zoom:80%;" />

Не имеет значения, что ставить сначала - Where или Include.

Include и ThenInclude - это методы DbSet, поэтому их нельзя применять, например, после операторов Find, FirstOrDefault и других, которые возвращают уже конкретный объект.

Include и ThenInclude загружают все связанные данные. Фильтровать их непосредственно в самом Include нельзя (но, к слову, у меня получилось это сделать в разделе проекции). Например, в следующем фрагменте запрос просто не видит поле с каналом, чтобы можно было задать для него какие-то условия:

<img src="img\image-20200507155357870.png" alt="image-20200507155357870" style="zoom:80%;" />

### Проекция

Если в методе Select использовать поля, содержащие связанные объекты, то они сами загружаются в память:

<img src="img\image-20200507150616074.png" alt="image-20200507150616074" style="zoom:80%;" />

Внешние .Where и .Select возвращают IQueryable, а внутренние - уже IEnumerable, что говорит о том, что в поле Channels анонимного объекта действительно будут данные, а не просто запрос.

Кроме того, в проекции я выполнил фильтрацию каналов, отобрав только только те каналы пользователя, которые предназначены для взрослых.

### Явная загрузка

Явная загрузка используется, когда главный объект уже находится в памяти и требуется догрузить связанные объекты.

* Для связи типа 1:М догрузка делается методом `Collection`:

<img src="img\image-20200507160502303.png" alt="image-20200507160502303" style="zoom:80%;" />

* Для связи типа 1:1 - методом `Reference`:

  <img src="img\image-20200507161527300.png" alt="image-20200507161527300" style="zoom:80%;" />

* Для связи типа М:М:

  В курсе не было, сам не нашел.

Догрузку можно делать только для одного объекта. Поэтому, если у нас несколько пользователей, которым нужна догрузка, то эффективнее будет сделать новый запрос, чем, например, в цикле делать догрузку явным способом.

Можно догружать не все связанные данные, а по условию:

<img src="img\image-20200507165543880.png" alt="image-20200507165543880" style="zoom:80%;" />

Для связи 1:1 у меня не получилось сделать.

### Ленивая загрузка

Ленивая загрузка позволяет автоматически загружать связанные данные, когда к ним происходит какое-либо обращение.

<img src="img\image-20200507171422228.png" alt="image-20200507171422228" style="zoom:80%;" />

Чтобы она работала, необходимо выполнить три действия:

* Поставить в сборку с контекстом пакет `Microsoft.EntityFrameworkCore.Proxies`

* Подключить ленивую загрузку при конфигурации контекста:

  <img src="img\image-20200507171725443.png" alt="image-20200507171725443" style="zoom:80%;" />

* Объявить все навигационные свойства во всех сущностях виртуальными:

  <img src="img\image-20200507172223283.png" alt="image-20200507172223283" style="zoom:80%;" />

Ленивая загрузка делает получение связанных данных менее очевидным плюс делает над сущностью обертку, искажая ее тип.

# Условия к связанным данным

Можно выбирать объекты на основе условий к их связанным данным. При этом не обязательно загружать связанные данные, если они не нужны непосредственно в результате:

<img src="img\image-20200507162819326.png" alt="image-20200507162819326" style="zoom:80%;" />

Выбрали пользователей, у который в домашней странице встречается часть "org".

<img src="img\image-20200507163336345.png" alt="image-20200507163336345" style="zoom:80%;" />

Выбрали пользователей, у который больше двух избранных каналов.
