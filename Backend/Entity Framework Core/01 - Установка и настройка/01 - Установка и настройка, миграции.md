# Контекст, миграции

**Контекстом** называется класс, унаследованный от EF-класса `DbContext`. Он является отправной точкой в работе с БД и реализует паттерн Unit of Work. Контекст можно создавать как вручную, так и воспользоваться командой `Scaffold-DbContext` для автоматического его формирования на основе указанной БД (процесс называется *реверс-инжиринг*).

**Миграции** - это инструмент для поддержания классов модели данных и БД в согласованном состоянии. Если в классы модели данных добавляются новые поля или удаляются старые, меняются типы, то с помощью миграций нужно внести эти изменения в БД. Таким образом, если вы например создали связь между сущностями, то должны применить эти изменения к БД через миграцию, иначе не сможете работать с сущностями задуманным образом, потому что в БД этой связи нет.

Миграции можно использовать и когда базы данных еще нет, и когда она уже существует.

Для работы требуются пакеты `Microsoft.EntityFrameworkCore.SqlServer` (или другой, смотря с какой СУБД планируется работать) и `Microsoft.EntityFrameworkCore.Tools`



# Установка и настройка

Классы, относящиеся к Entity Framework, принято размещать в отдельной сборке-библиотеке. В этом случае для работы команд из пакета `Tools` потребуется сборка, которая может выполниться, и установленный в нее пакет `Microsoft.EntityFramework.Design`. 

В данной инструкции для этого используется консольный проект. Но в случае, если в решении есть, например, ASP.NET Core проект, можно использовать его.

<img src="img\image-20200502082650706.png" alt="image-20200502082650706" style="zoom: 80%;" />

* В сборку **EFCoreBase.DAL** устанавливаем пакеты `Microsoft.EntityFrameworkCore.SqlServer` и `Microsoft.EntityFrameworkCore.Tools`
* В сборку **EFCoreBase.ConsoleClient** устанавливаем пакет `Microsoft.EntityFrameworkCore.Design`
* Устанавливаем **ConsoleClient** как проект по умолчанию (`ПКМ > Set as Startup Project`)
* В **ConsoleClient** добавляем ссылку на **DAL**

Теперь выбираем в главном меню `Tools > NuGet Package Manager > Package Manager Console`

<img src="img\image-20200502085739663.png" alt="image-20200502085739663" style="zoom:80%;" />

и в нем в качестве Default Project выбираем DAL.

> Внимание: это разные Default Project. В окне решения проектом по умолчанию должен быть ConsoleClient, а здесь - DAL. Первый нужен просто чтобы могли выполниться команды, а второй содержит контекст.

Теперь, после проведения этих настроек, можно использовать в этой консоли (PMC) команды для работы с контекстом и миграциями.



# Существующая БД

## Контекст из существующей БД

Для автоматического формирования класса контекста на основе уже существующей БД, используется команда `Scaffold-DbContext`. Ее параметры:

* `-Connection` - строка соединения с БД
* `-Provider` - провайдер БД

* `-ContextDir`, `-OutputDir` - по умолчанию все сгенерированные классы помещаются в корневую папку проекта. Для лучшей структуризации можно задать отдельные папки для файлов контекста и сущностей (папки будут созданы автоматически)
* `-Tables` - перенести в модель не все таблицы, а только указанные
* `-Context` - по умолчанию класс контекста называется ИмяБазыДанныхContext. С помощью этого параметра можно задать другое имя
* `-UseDatabaseNames` - использовать имена таблиц и полей точно в том виде, в каком они есть в БД. Без этого параметра в процессе переноса некоторые имена могут быть изменены, чтобы больше соответствовать правилам именования .NET
* `-DataAnnotations` - с этим параметром для описания модели будет использован стиль Data Annotations. По умолчанию используется стиль Fluent Api.

Пример команды:

```c#
Scaffold-DbContext -Connection "Data Source=SHADOWWWPC;Initial Catalog=Northwind;Integrated Security=True;" -Provider Microsoft.EntityFrameworkCore.SqlServer -OutputDir "EF/Entities" -ContextDir "EF" -Tables Employees, Orders
```

Если БД - локальная, то параметр Connect выглядит так:

```c#
-Connection "Data Source = (localdb)\MSSQLLocalDB; Initial Catalog = SamuraiAppData"
```



Строку соединения можно получить следующим образом:

* В главном меню выбираем `View > Sql Server Object Explorer`

  <img src="img\image-20200502094332077.png" alt="image-20200502094332077" style="zoom:80%;" />

* Разворачиваем нужную базу данных. После этого, если выделить ее, то из Properties можно скопировать строку соединения:

  <img src="img\image-20200502094531262.png" alt="image-20200502094531262" style="zoom:80%;" />



## Миграции к существующей БД

* Создаем миграцию с именем Init, выполнив команду `Add-Migration Init`

* Если миграция создалась успешно, в корне проекта появляется папка Migrations, а в ней - файл с первой миграцией:

  <img src="img\image-20200502101602778.png" alt="image-20200502101602778" style="zoom:80%;" />

* Из ее метода Up удаляем все содержимое, чтобы он был пустой:

  <img src="img\image-20200502102259297.png" alt="image-20200502102259297" style="zoom:80%;" />

* Применяем миграцию, выполнив команду `Update-Database`

* Если все прошло успешно, в БД появляется таблица с историей применения миграций:

  <img src="img\image-20200502102118092.png" alt="image-20200502102118092" style="zoom:80%;" />

С этого момента можно использовать обычный порядок работы с миграциями.

Метод Up содержит команды, позволяющие привести БД в состояние, описываемое миграцией. Когда мы создаем миграцию к уже существующей БД, у нее в методе Up образуются команды на создание таблиц и всего остального. При попытке применить миграцию, эти команды начинают выполняться, система пытается создать таблицы, но поскольку они уже существуют, возникает ошибка. Поэтому мы и очищаем предварительно метод Up. В таком случае миграция получается как бы пустая - никаких команд не выполняется, но сама миграция применяется и заносится в историю, после чего порядок работы входит в обычное русло.



# Миграции

Алгоритм работы с миграциями прост:

* Создать миграцию
* Применить ее

## Создание миграций

Папка с миграциями содержит непосредственно миграции и снапшот:

<img src="img\image-20200502104510524.png" alt="image-20200502104510524" style="zoom:80%;" />

**Снапшот** - это снимок модели данных на текущий момент. В нем описаны все сущности, их поля, типы и прочее:

<img src="img\image-20200502104716373.png" alt="image-20200502104716373" style="zoom:80%;" />

Когда вы вносите в модель данных изменения и хотите отразить их на БД, вы создаете новую миграцию командой `Add-Migration Name`. При этом все классы сущностей сравниваются со своими версиями, которые описаны в снапшоте, и таким образом выявляются изменения. Эти изменения и формируют содержимое миграции:

<img src="img\image-20200502105823822.png" alt="image-20200502105823822" style="zoom:80%;" />

Метод Up содержит вносимые изменения, а метод Down - как их откатить.

## Применение миграций

Для применения миграций могут использоваться две команды:

* `Update-Database` - автоматически применяет изменения, описанные в миграциях

* `Script-Database` - генерирует на основе миграций SQL-команды, которые надо запускать вручную

Первая хорошо подходит для developer-версии БД, а вторая - для production-версии.

### Команда Update-Database

Команда `Update-Database` без параметров применяет всю последовательность имеющихся миграций. Анализируется текущее состояние модели данных и применяются только полезные изменения.

Когда изменения вносятся в структуру БД, также обновляется и снапшот, чтобы соответствовать текущему состоянию модели данных. Из этого становится понятно, что под "текущим состоянием" снапшота понимается именно зафиксированное с помощью миграции состояние. Если просто вносить в классы сущностей изменения, не фиксируя их миграциями, то в снапшоте, понятное дело, эти изменения никак не отразятся.

Указывая имя, можно перемещаться на конкретную миграцию, откатываясь либо поднимаясь таким образом до желаемого состояния БД. Например, чтобы отменить миграцию FullNameAdded,  можно применить миграцию Init: `Update-Database Init -verbose`. Параметр -verbose заставляет выводить в консоль полный список происходящих действий.  

В таблице истории отражается последовательность всех примененных миграций:

<img src="img\image-20200502111154070.png" alt="image-20200502111154070" style="zoom:80%;" />

Перемещение по миграциям влияет только на состояние БД. Это значит, что если отменить миграцию FullNameAdded, то поле FullName исчезнет только из БД (данные в этом поле потеряются), но в классе Employees поле останется.

### Команда Script-Migration

Введенная без параметров, генерирует SQL для полного списка миграций.

Параметры:

`-From` - миграция, начиная с которой надо генерировать код. Значение 0 трактуется по особому и означает "перед первой миграцией"

`-To` - миграция, до которой (включительно) надо генерировать код

```c#
Script-Migration -From 0 -To 20200502073953_FullNameAdded
```
