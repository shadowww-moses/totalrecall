# Предисловие

Я не знал, как законспектировать все эти вещи линейно. Потому что то тут, то там возникали перекрестные ссылки. Поэтому я постарался отдельно в начале описать идеи, не особо снабжая их примерами (или добавлял зарисовки, которые можно назвать примерами чисто условно), а уже в конце сделал раздел целиком из примеров.

Эти примеры я проверил и снабдил подробными комментариями, частично дублирующими теорию и ссылающимися на нее. Комбинаций все равно возможно много, всех не описать. Поэтому я как мог попытался описать базовые случаи, из которых комбинируется все остальное, что может существовать, но не описано. Так что в целом работа с мануалом сводится не к тому, чтобы быстро выцепить что-то конкретное, а к тому, чтобы прочитать все, вникнуть, и смочь самому додуматься до решения искомой задачи.

Для примеров будет использоваться следующая диаграмма:

<img src="img\image-20200502141350264.png" alt="image-20200502141350264" style="zoom:80%;" />

Будем рассматривать отношения

* **Один-к-одному** (1:1) - у пользователя может быть только одна домашняя страница
* **Один-ко-многим** (1:M) - у пользователя может быть много плейлистов. При этом плейлистами нельзя делиться, так что каждый плейлист может принадлежать только одному пользователю
* **Многие-ко-многим** (M:M) - пользователь может быть подписан на много каналов, а у каналов может быть много подписчиков



# Создание контекста

БД пока не существует.

* Подключаем неймспейс `Microsoft.EntityFrameworkCore`

* Создаем класс контекста, наследуясь от `DbContext`

* Настраиваем соединение с БД в методе `OnConfiguring()`. Если начать набирать `override On`, то выскочит удобная подсказка, которая автоматически создаст каркас метода, в который останется дописать желаемые опции:

  <img src="img\image-20200502174548432.png" alt="image-20200502174548432" style="zoom:80%;" />

* В контексте два основных метода - в `OnConfiguring` настраивается сам контекст, а в `OnModelCreating` проводятся настройки для сущностей

* Поскольку БД еще не существует, можно в консольный проект добавить строчки

  ```c#
  var context = new YoucubeContext();
  context.Database.EnsureCreated();
  ```

  и запустить его, чтобы база создалась



# Создание таблиц

Когда классы модели данных оформлены соответствующим образом, нужно создать и применить миграцию, чтобы EF создал таблицы по этой модели, после чего с ними можно будет работать.

Чтобы убедиться, что EF распознал отношения между сущностями именно так, как задумано, можно перед созданием миграции сгенерировать визуальную схему с помощью `EF Power Tools` (описано в конспекте "Установка и настройка") и оценить картину.



## 1:1 User → Homepage

► Все классы должны иметь поле `Id` числового типа (например int, long), которые EF использует как первичный ключ:

<img src="img\image-20200502165457669.png" alt="image-20200502165457669" style="zoom:80%;" />

Поле `Homepage` в классе `User` называется **навигационным свойством**. По его типу нему EF поймет, что надо организовать связь с классом `Homepage`. 

Со стороны класса `Homepage` мы задаем поле `int UserId` - это внешний ключ, который свяжется с Id из User. Он должен иметь название в формате *КлассДляСвязиId* и иметь такой же тип.

► Если подчиненная сущность может существовать без главной, внешний ключ надо сделать nullable (int?). Пример: самурай и лошадь. У каждого самурая может быть только одна лошадь, и если лошадь выдана самураю, то другие на ней ездить не могут. Однако лошадь может стоять в общем стойле и быть какое-то время бесхозной. В нашем примере предполагается, что если страница есть, значит она принадлежит пользователю. Если нет пользователя, то не может быть и страницы, поэтому поле не nullable.

► Чтобы непосредственно работать с таблицей пользователей, нужно добавить в контекст поле типа DbSet, инициализированное типом сущности:

<img src="img\image-20200502171010462.png" alt="image-20200502171010462" style="zoom:80%;" />

Если мы не хотим отдельно работать с домашними страницами в программе, то DbSet для Homepage можем не добавлять.

### Настройка имен для таблиц

Таблицы получают имена по именам DbSet'ов, описанных в контексте. Таблица пользователей, например, получит имя Users.

Поскольку мы решили, что не хотим отдельно работать с домашними страницами и не добавили `DbSet<Homepage>` в контекст, то имя для нее подберется автоматически - `Homepage`.

Если нас это не устраивает (а мы хотим, чтобы таблицы имели названия во множественном числе например), мы можем явно указать имя для таблиц, связанных с нашими сущностями. Это делается в методе `OnModelCreating` контекста:

<img src="img\image-20200502171837303.png" alt="image-20200502171837303" style="zoom:80%;" />



## 1:M User → Playlist

<img src="img\image-20200507082947795.png" alt="image-20200507082947795" style="zoom:80%;" />

Связь 1:М содержит список в главной сущности и внешний ключ в зависимой. Можно еще добавить навигационное свойство при необходимости. Она нормально определяется EF и проводить дополнительных настроек в методе построения модели не надо.



## M:M User ↔ Channel

► Для организации между двумя сущностями связи Многие-ко-Многим требуется третья промежуточная сущность:

<img src="img\image-20200503083650396.png" alt="image-20200503083650396" style="zoom:80%;" />

(Выделение памяти под список пропущено для краткости, принято делать это в конструкторе)

Навигационные свойства `Channel` и `User` в промежуточной сущности не являются обязательными, но могут упростить добавление объектов.

► В контексте нужно явно настроить для промежуточной сущности первичный ключ:

<img src="img\image-20200503084727085.png" alt="image-20200503084727085" style="zoom:80%;" />
