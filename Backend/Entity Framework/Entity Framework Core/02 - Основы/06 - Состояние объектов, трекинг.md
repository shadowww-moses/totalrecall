# Состояние объектов, трекинг

► EF отслеживает состояние всех сущностей, с которыми работает. Это называется трекингом. За трекинг отвечает объект `ChangeTracker`, находящийся среди свойств контекста.

Существует **4 метода трекинга**: `Add`, `Update`, `Remove`, `Attach`

В зависимости от того, уже сохранен объект в базу данных или еще нет, методы трекинга устанавливают его в разное состояние:

<img src="img\image-20200503093919503.png" alt="image-20200503093919503" style="zoom:80%;" />

> Если объект еще не сохранен в БД, его Id равен 0

Состояние не является частью отслеживаемого объекта. Оно хранится внутри контекста.

![image-20200506155507456](img\image-20200506155507456.png)



Названия методов трекинга довольно условны. Например, код

```c#
var user = new User(...);
context.Users.Update(user);
context.SaveChanges();
```

вполне успешно добавит нового пользователя в таблицу, хотя метод называется Update, а этот пользователь в таблице еще даже не существует. Поскольку у этого нового объекта Id = 0 и метод Update ставит его в состояние *Added* (как показано на картинке), то EF проведет именно добавление этого объекта в таблицу.

Поэтому следует отталкиваться от понимания того, что это за объект и следовательно в каком состоянии он находится, и исходя из этого уже выбирать метод для установки трекинга этого объекта.

Аналогично

```c#
var Sam = new User("Sam");
context.Users.Add(Sam);
Sam.Name = "Tom";

var Jack = context.Users.Find(5);
Jack.Name = "Frodo";
context.Users.Update(Jack);

context.SaveChanges();
```

не "Добавляет нового пользователя по имени Sam в таблицу Users", а устанавливает объект Sam в состояние "Added" и начинает его отслеживать; не "изменяет имя в объекте Jack на Frodo",  а устанавливает объект Jack в состояние "Modified".

> Вообще, в данном случае вызывать Update для объект Jack не обязательно. Ведь контекст начинает отслеживать этот объект после получения, а поскольку это Connected сценарий, то контекст сам поймет, что объект изменился, когда мы присвоим новое имя. Я специально оставляю этот код и этот комментарий для явного объяснения данной ситуации

А уже при вызове метода `SaveChanges` контекста, EF обходит граф объектов и выполняет с ними нужные действия относительно БД. Поэтому объект Sam сохранится с именем Tom.

► Размышление о работе с сущностями в терминах отслеживания позволяет лучше понимать, что происходит. Например, после сохранения пользователь по имени Tom получит свой Id, который можно будет тут же узнать без дополнительных усилий через объект Sam, поскольку контекст этот объект отслеживает.

Для *Disconnected сценариев*, когда объекты не отслеживаются контекстом и надо вручную задавать и понимать их состояние, важно помнить, что методы трекинга устанавливают состояние не только для корневого объекта, но и для всех вложенных:

![image-20200504115903568](img\image-20200504115903568.png)

# Отключение трекинга

Автоматический трекинг - удобная функция, позволяющая сделать работу с сущностями проще и эффективнее.  Например, в такой ситуации

```c#
var context = new YoucubeContext();
var user = context.Users.FirstOrDefault(u => u.Username == "ShadowwwMoses");
user.Username = "ShadowMoses";
context.SaveChanges();
```

контекст за счет отслеживания объекта, во-первых, сам поймет, что произошли изменения и переведет объект в состояние modified, а, во-вторых, сгенерирует запрос, который обновит только действительно изменившиеся поля:

```mssql
UPDATE [Users] SET [Username] = @p0
WHERE [Id] = @p1;
```

Однако, автоматический трекинг требует некоторых ресурсов и в некоторых ситуациях (например, в случае Disconnected-сценария) невозможен. Для таких случаев есть несколько способов отключить его:

* В методе OnConfiguring контекста:

  <img src="img\image-20200503103027520.png" alt="image-20200503103027520" style="zoom:80%;" />

* В конструкторе контекста:

  <img src="img\image-20200503103212793.png" alt="image-20200503103212793" style="zoom:80%;" />

  Свойство `ChangeTracker` наследуется от родителя

* Методом `AsNoTracking()` при получении объекта с помощью DbSet:

  ```c#
  var context = new YoucubeContext();
  var user = context.Users.AsNoTracking()
      .FirstOrDefault(u => u.Id == 5);
  ```

  В этом случае такую операцию надо проводить для каждого запроса. К тому же, результатом выполнения `AsNoTracking()` является `IQueryable`, а значит мы теряем возможность пользоваться методами DbSet, например, `Find`

При отключенном автоматическом трекинге первый пример принимает такую форму:

```c#
var context = new YoucubeContext();
var user = context.Users.AsNoTracking()
    .FirstOrDefault(u => u.Username == "ShadowwwMoses");
user.Username = "ShadowMoses";
context.Update(user);
context.SaveChanges();
```

Во-первых, нам пришлось вручную поставить объекту статус modified, применив метод Update контекста. Во-вторых, EF сгенерировал вот такой SQL-запрос:

```mssql
UPDATE [Users] SET [Age] = @p0, [Browser] = @p1, [County] = @p2, [Username] = @p3
WHERE [Id] = @p4;
```

из которого видно, что перезаписываются все поля, хотя мы изменили всего лишь одно.

# Проверка состояния объекта перед сохранением

Иногда при отладке бывает полезно узнать, в каком состоянии находятся объекты перед сохранением. Это можно сделать, если перед сохранением вызвать метод `DetectChanges`:

```c#
contextPost.ChangeTracker.DetectChanges();
contextPost.SaveChanges();
```

Этот метод вызывается внутри SaveChanges автоматически, но поскольку мы хотим проследить состояние *до* сохранения, то можем вызывать его вручную.

После этого, если поставить на SaveChanges точку останова и добавить в watch свойство `contextPost.ChangeTracker.Entities()` (добавлять надо вручную, метод Entities() не виден, если просто просматривать список свойств), можно увидеть вот такую картину:

<img src="img\image-20200504143230370.png" alt="image-20200504143230370" style="zoom:80%;" />

# Отслеживаемые записи

Все записи, которые в данный момент отслеживает трекер, доступны через его метод `Entries()`:

<img src="img\image-20200509091324786.png" alt="image-20200509091324786" style="zoom:80%;" />
