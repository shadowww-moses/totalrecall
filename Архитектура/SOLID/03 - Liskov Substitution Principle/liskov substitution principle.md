# Определение

Сама Барбара Лисков сформулировала этот принцип так (я совсем немножко подправил):

*"Если S является подтипом T, тогда объекты T можно заменить на объекты S без нарушения работы программы"*

То есть принцип относится к проектированию иерархий наследования и нацелен на то, чтобы клиент мог надежно пользоваться любым классом иерархии без боязни, что их взаимозамена приведет к ошибке.

Правила, формирующие LSP, связаны с двумя понятиями - понятие контракта и понятие вариантности. О каждой категории поговорим отдельно.

# Контракты

Прежде всего, `интерфейс != контракт`, это не одно и то же. Контракт - это скорее концептуальное понятие, которое нужно обеспечить программно. А как - уже дело второе.

Например, вот *интерфейс* метода:

```c#
decimal CalculateShippingCost(
    float packageWeightInKilograms,
	Size<float> packageDimensionsInInches,
	RegionInfo destination)
```

Этот *интерфейс* говорит нам о том, что, например, результатом работы метода является число и вес посылки тоже является числом. Через имя метода и параметров сообщается о том, что результат работы - это стоимость доставки, а вес посылки задается в килограммах, а не фунтах например.

Однако, *контракт*, связанный с этим методом, по сути включает в себя больше информации - цена отправки не может быть отрицательной или нулевой, да и вес тоже. И вот контроль этих вещей интерфейс сам по себе никак не обеспечивает.

## Правила контрактов

С контрактами связано три правила:

* Подтип не может усилять предусловия

* Подтип не может ослаблять постусловия
* Подтип обязан сохранять инварианты супертипа (инварианты - это условия, которые должны оставаться истинным на протяжении всей жизни объекта. Например, вес в объекте посылки должен быть больше нуля все время)

## Обеспечение правил

Обеспечить выполнение этих правил можно разными способами. Например, путем введения дополнительных условий в начале и в конце метода:

```c#
decimal CalculateShippingCost(
    float packageWeightInKilograms,
	Size<float> packageDimensionsInInches,
	RegionInfo destination)
{
    if (packageWeightInKilogramms <= 0f)
        throw new ArgumentOutOfRangeException("packageWeightInKilogramms",
                                              "Вес пакета должен быть больше нуля");
    var shippigCost = // Расчитываем стоимость

	if (shippingCost < decimal.Zero)
        throw new ArgumentOutOfRangeException("return", "Стоимость доставки не может быть отрицательной");
    
    return shippingCost;
}
```

Однако этот способ не очень хорош, потому что по сути обеспечиваемые здесь контракты относятся не к *процессу расчета стоимости*, а именно к *самой стоимости доставки* и к "весу посылки". Поэтому если где-нибудь еще будет использоваться вес посылки, этот код условия придется дублировать. Здесь *положительный вес является инвариантом типа, а не предусловием метода*. Так что правильным решением будет выделить вес в отдельный тип и реализовать проверку там.

В предусловиях могут участвовать только параметры метода и открытая часть состояния объекта. Потому что если предусловие будет нарушаться из-за чего-то, на что клиент не может повлиять, это логически неправильно. Например, клиент может передать неправильный вес - это его ошибка и он должен ее решить. Но если он все передал правильно, но предусловие не позволяет выполнить метод из-за каких-то внутренних ошибок, то заставлять клиента страдать в этом случае неправильно и несправедливо, потому что он не может повлиять на внутренние аспекты объекта.

Инварианты относятся к состоянию объекта. Обеспечить их сохранение тоже можно разными способами. Например, если свойство устанавливается единожды при создании объекта, то можно сделать проверку в конструкторе. А если оно может изменяться потом, тогда проверку можно реализовать в сеттере.



# Вариантность и контравариантность

► В подтипе должна существовать контравариантность аргументов методов

> Возможно, это означает, что "в метод потомка можно передать аргументы другого типа, не как в родителе", будем разбираться в этом дальше

► В подтипе должна существовать ковариантность возвращаемых типов

> Мб, это значит "в методе потомка всегда должен возвращаться такой же тип, как в родителе"

► В подтипе нельзя генерировать новые исключения, если они не принадлежат существующей иерархии исключений

В .NET эти понятия относятся к дженерикам и делегатам