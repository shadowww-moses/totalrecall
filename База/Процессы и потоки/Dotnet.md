# Тезисы

Для работы с потоками есть класс `Thread`. Самый низкоуровневый вариант.

Задачи - более высокоуровневая конструкция для работы с потоками, класс `Task`, делающая работу с ними более комфортной.

Пул потоков - CLR заранее создает несколько потоков и использует их для выполнения работ, чтобы не создавать каждый раз новый поток, потому что это затратно. Задачи, запускаемые через `Task.Run` используют потоки из пула.

Превышение лимита CPU - это когда количество активных потоков больше количества аппаратных ядер процессора.

Потоки бывают переднего плана (*foreground*) и фоновые (*background*). Явно создаваемые потоки по умолчанию являются foreground, а потоки из пула - фоновыми.

Выполняемые функции делятся на две группы - интенсивные вычисления и интенсивный ввод-вывод. Ко второй категории не обязательно относятся только те операции, которые ждут ввода, а вообще любые операции, которые большую часть своего времени чего-то ждут. Например, загрузка большой веб-страницы.

Потоки из пула не следует использовать для выполнения работ с интенсивным IO. Это может просадить производительность. Их используют для быстрых работ (< 100-250 мс) с интенсивными вычислениями.

Автономные задачи - это задачи, которые запускаются по принципу "запустил и забыл". Их не дожидаются и они не возвращают результат.

Работы можно организовывать в цепочки, подключая их одна к другой.

Работы можно отменять. При этом выбрасывается исключение `OperationCancelledException`. Поэтому с технической позиции отмена и любое другое исключение - это одно и то же. Но с логической это разные вещи и для них используются разные свойства.

Класс `TaskCompletionSource` позволяет внести удобство задач в работу с потоками, при этом не задействуя пул потоков.

# Вопросы

- [ ] `.ConfigureAwait(false)` - что делает этот метод и как он связан с контекстом синхронизации

# Потоки

```c#
using System.Threading;
```

## Создание потока, запуск и передача параметров

```c#
static void Main(string[] args)
{
    var t1 = new Thread(PrintMessage);
    string message = "Hello, paramed thread!";
    var t2 = new Thread(() => PrintCustomMessage(message));

    t1.Start();
    t2.Start();
}

static void PrintMessage()
{
    Console.WriteLine("Hello, threads!");
}

static void PrintCustomMessage(string message)
{
    Console.WriteLine(message);
}
```

Параметры в потоки можно передавать через лямбды.

Поток работает, пока не выполнятся все команды в запущенной в нем функции. Когда поток завершен, повторно его запустить нельзя, нужно создавать новый. Если поток уже выполняется, то запустить его еще раз тоже нельзя. 

## Ожидание, усыпление, получение результата

Один поток может дожидаться окончания выполнения другого потока с помощью команды `Join()`. Ей можно передать таймаут, после которого ожидание прекращается:

```c#
static void Main(string[] args)
{
    var t1 = new Thread(() => { Thread.Sleep(2000); Console.WriteLine("Wake up!"); } );
    t1.IsBackground = true;
    t1.Start();

    Console.WriteLine("Before Join");
    bool waitResult = t1.Join(3000);  // Вернет true, если дождался, и false - если нет

    Console.WriteLine(waitResult);  // true
}
// Before Join
// Wake up!
// true
```

Пока поток ожидает, он переходит в состояние `Blocked` и ему не выделяется процессорное время. В этом примере главный поток ожидает поток `t1` 3 секунды. То есть в ожидание переходит тот поток, ***в котором*** вызван Join, а не ***на котором***.

С помощью статического метода `Thread.Sleep` можно усыпить текущий поток на указанное время. Он тоже становится `Blocked` и не потребляет процессорное время.

Если в `Sleep` передать 0, поток моментально освободит процессор. Есть дополнительный метод `Thread.Yield()` - он отдает процессор любому потоку, который выполняется на том же процессоре (именно процессоре, а не процессе).

Чтобы получить результат из потока, нужно воспользоваться объектом класса `TaskCompletionSource`, об этом дальше.

## Переключение контекста, блокировка и зацикливание

Можно по-разному обыграть ситуацию, когда потоку нужно чего-то дождаться:

* Блокирование
* Зацикливание
* Колбэк

Блокирование подразумевает передачу процессора другому потоку. Это может быть не очень эффективным, поскольку эта операция требует участия CLR и ОС и переключения контекста, который занимает 1-2 микросекунды.

Если ожидание потенциально длится мало, то дешевле может оказаться использование зацикливания. Для этого есть специальные классы `SpinLock` и `SpinWait`.

Наиболее эффективный способ - использование асинхронного кода и колбэков. Об этом дальше, в задачах и await.

## Локальное и разделяемое состояние

Есть два понятия - ***локальное состояние*** и ***разделяемое состояние***. Первое - это все переменные, доступные только внутри потока, а второе - доступные всем потокам (в пределах процесса).

Для каждого потока CLR выделяет персональное место в памяти для хранения стека. Поэтому если какая-то функция выполняется внутри потока, то все ее локальные переменные доступны только внутри этого потока. Это локальное состояние.

```c#
static void Main(string[] args)
{
    ThreadStart act = () => { int cnt = 0; while (cnt < 10) Console.WriteLine(cnt++); };

    var t1 = new Thread(act);
    var t2 = new Thread(act);
    
    Console.WriteLine("t1 output:");
    t1.Start();
    t1.Join();

    Console.WriteLine("t2 output:");
    t2.Start();

    Console.WriteLine("Конец");
}
```

В этом примере оба вывода будут содержать цифры от 0 до 9.

Если локальная переменная захвачена лямбдой, которая передана в поток, то эта переменная становится *разделяемой*. Также разделяемое состояние можно организовать с помощью переменных, принадлежащих одному и тому же объекту, или статическому классу.

Если в предыдущем примере перенести объявление `cnt` в метод `Main`

```c#
int cnt = 0;
ThreadStart act = () => { while (cnt < 10) Console.WriteLine(cnt++); };
```

то только вывод для потока t1 будет содержать цифры от 0 до 9, а для t2 не выведется ничего, потому что cnt для  обоих потоков общая и к моменту выполнения второго, она уже равна 10.

```c#
class Program
{
    private int _cnt = 0;  // Можно сделать ее статической

    static void Main(string[] args)
    {
        var prog = new Program();

        var t1 = new Thread(prog.PrintCnt);  // Тогда сюда передавать статик метод
        Console.WriteLine("t1");
        t1.Start();  // 0
        t1.Join();

        var t2 = new Thread(prog.PrintCnt);
        Console.WriteLine("t2");
        t2.Start();  // 1

        Console.WriteLine("Конец");  // Результат будет такой же - 0 и 1
    }

    void PrintCnt()  // И метод статическим
    {
        Console.WriteLine(_cnt++);
    }
}
```

## Потокобезопасность, оператор lock

Потокобезопасность - это такая организация доступа к общим переменным, при которой потоки не затирают результаты работы друг друга, иными словами, решается проблема `Race condition`. В следующем примере из-за того, что критическая секция никак не охраняется, два потока мешают друг другу и в итоге `_cnt` равно не 200_000, как планировалось, а каждый раз имеет разное значение. Если количество итераций цикла небольшое, то эффект может не проявляться, потому что весь цикл успевает выполниться за один квант времени. Но уже начиная с 2000 появляются сбои и с какого-то момента правильный результат получить невозможно:

```c#
class Program
{
    private static int _cnt = 0;

    static void Main(string[] args)
    {
        var t1 = new Thread(IncCnt);
        var t2 = new Thread(IncCnt);

        t1.Start();
        t2.Start();

        t1.Join();
        t2.Join();

        Console.WriteLine($"cnt: {_cnt}");
    }

    static void IncCnt()
    {
        for (var i = 0; i < 100_000; i++)
        {
            _cnt++;  // Критическая секция не охраняется
        }
    }
}
```

Оператор `lock` позволяет реализовать концепцию `Locking Variable` в борьбе с Race Condition:

```c#
class Program
{
    private static object _lockCnt = new object();
    private static int _cnt = 0;

    static void Main(string[] args)
    {
        var t1 = new Thread(IncCnt);
        var t2 = new Thread(IncCnt);

        t1.Start();
        t2.Start();

        t1.Join();
        t2.Join();

        Console.WriteLine($"cnt: {_cnt}");
    }

    static void IncCnt()
    {
        for (var i = 0; i < 100_000; i++)
        {
            lock (_lockCnt)
            {
                _cnt++;  // Защищаем критическую секцию
            }
        }
    }
}
```

Для `lock` подойдет любая переменная ссылочного типа. В `lock` оборачивает только непосредственно те строчки, которые формируют критическую секцию.

## Foreground и Background потоки

При создании, по умолчанию поток создается как ***foreground***, и программа будет ждать, пока отработают все foreground потоки, прежде чем завершится. На выполнение потоку Windows выдает кванты примерно по 20 миллисекунд. Чтобы сделать поток ***фоновым***, нужно установить свойство `isBackground = true`. Программа *не ждет* завершения таких потоков.

```c#
static void Main(string[] args)
{
    var t1 = new Thread(() => Thread.Sleep(4000));
    t1.Start();

    Console.WriteLine("That's all, folks!");
}
// That's all, folks!  // Но программа завершится только через 4 секунды после надписи
```

В связи с этим, если вдруг в фоновом потоке используются конструкции `using` или `finally` для освобождения ресурсов, то эти блоки не выполнятся. С этим надо быть внимательным и дожидаться фоновых потоков при такой необходимости.

## Пул потоков

Пул потоков - это заранее создаваемый CLR набор потоков, который затем используется для выполнения коротких работ. Создание заранее позволяет избежать накладных расходов на выделение памяти под стек потока и других инфраструктурных вещей. Поток используется, а затем не уничтожается, а возвращается в пул и может быть использован повторно. У потоков из пула есть несколько особенностей:

* Им нельзя давать имя
* Им можно менять приоритет, но после возвращение потока в пул приоритет сбросится на исходный
* Их лучше не блокировать и не использовать для тяжелых вычислений - это может сильно снизить производительность

Два способа запустить работу в потоке из пула - через задачи и старый способ, когда задач еще не было:

```c#
using System.Threading;
using System.Threading.Tasks;

static void Main(string[] args)
{
    Task.Run(() => Console.WriteLine("Hello Thread Pool!"));
    ThreadPool.QueueUserWorkItem(notUsed => Console.WriteLine("Oldschool"));
    // notUsed имеет тип WaitCallback - делегат

    Console.WriteLine("That's all, folks!");
}
```

Есть понятие ***превышение лимита ЦП*** - это когда количество активных потоков больше количества аппаратных ядер процессора. Поэтому CLR старается не допускать этого за счет постановки работ в очередь, чтобы одновременно выполнялось не больше потоков, чем количество ядер. Чтобы упростить ей задачу, при работе с пулом нужно соблюдать две вещи:

* Не запускать в пуле работы, которые занимают больше 100-250 милисекунд
* Не запускать работы, которые будут большую часть времени заблокированными

P.S. ??? Очень странная тема. Во-первых, откуда я могу знать, сколько мс займет выполнение функции? Во-вторых, если потоку нужно ждать, то что же теперь делать? Запускать его через тред? В общем, эту тему нужно впоследствии разбирать отдельно при необходимости.

## Обработка исключений

```c#
static void Main(string[] args)
{
    try
    {
        new Thread(() => { Thread.Sleep(3000); throw new Exception(); }).Start();
    }
    catch
    {
        Console.WriteLine("Обработано");  // Никогда сюда не попадем
    }
}
```

У каждого потока свой путь выполнения, поэтому обрабатывать исключения нужно *внутри* потока. Извне поймать его невозможно. При этом непойманное исключение кладет весь процесс, а не только поток, в котором возникло.

## Контекст синхронизации

Стр. 570. Я вроде разобрался в теме, но не стал сюда ее заносить, потому что она похоже актуальна только для программ с GUI и ASP. По крайней мере, в консоли реализовать нормальный пример сходу не получилось.

## Некоторые свойства потоков

* `thr.isAlive` - возвращает true, пока поток не закончит свое выполнение.
* `thr.Name` - потоку можно задать имя, чтобы упростить отладку. Имя задается только один раз.
* `Thread.CurrentThread` - возвращает поток, который выполняется в текущий момент.
* `thr.isBackground = true` - делает поток фоновым.
* `thr.ThreadState` - свойство с состоянием потока, флаговое перечисление. Используется в комбинации с `ThreadState`. Потом досмотреть отдельно, когда реально пригодится. Комбинации получаются неоднозначные.
* `thr.Priority = ThreadPriority.Highest` - приоритет потока
* `Thread.CurrentThread.IsThreadPoolThread` - является ли поток потоком из пула

# Задачи

## Создание, ожидание, возврат значения, правила

```c#
using System.Threading.Tasks;
```

Задачи являются более высокоуровневым способом организации параллельной обработки. Два главных преимущества задач перед потоками:

* Легкость получения результата работы
* Легкость чейнинга работ

Самый простой способ запустить задачу, подкрепленную потоком:

```c#
static void Main(string[] args)
{
    Task t1 = Task.Run(() => Thread.Sleep(3000));
    bool w = t1.Wait(2000);  // Можно указать таймаут, в течение которого надо ждать задачу

    Console.WriteLine(w);  // false
}
```

- [ ] ??? А что значит "подкрепленную потоком"? То есть задача может разве выполняться не в потоке? Абсурд

Работа сразу же начинает выполняться, а метод возвращает объект задачи. Так же, как и поток, задачу можно дождаться. При вызове `Task.Run` используются потоки из пула (значит они фоновые по умолчанию), поэтому лучше использовать этот способ для выполнения быстрых функций с интенсивными вычислениями.

Передача значений и получение результата:

```c#
static void Main(string[] args)
{
    string username = "JohNy";
    Task<string> t1 = Task.Run(() => { Thread.Sleep(3000); return $"Hello, {username}!"; });

    Console.WriteLine(t1.Result);
    Console.WriteLine("That's all, folks!");
}
```

Если на момент обращения к свойству `Result` задача еще не выполнилась, текущий поток блокируется.

Хотя запуск одной тяжелой задачи не сильно понизит производительность, запуск нескольких - может. В этом случае можно использовать такой способ:

```c#
Task t1 = Task.Factory.StartNew(() =>
    {
        Thread.Sleep(4000);
        Console.WriteLine("4 sec later");
    },
    TaskCreationOptions.LongRunning
);
t1.Wait();

Console.WriteLine("That's all, folks!");
```

## Тяжелые вычисления

Для тяжелых вычислений на самом деле лучше использовать очередь производителей\потребителей (глава 23).

Для работ с интенсивным IO лучше использовать потоки + класс TaskCompletionSource

## Исключения и автономные задачи

В отличие от потоков, если в задаче возникает исключение, то его легко поймать за счет того, что оно выбрасывается повторно при попытке дождаться задачу или получить результат:

```c#
static void Main(string[] args)
{
    Task t1 = Task.Run(() => { throw new ApplicationException(); });

    try 
    { 
        t1.Wait();  // Или var res = t1.Result;
    }
    catch (AggregateException ex)
    {
        if (ex.InnerException is ApplicationException)
        {
            Console.WriteLine("ApplicationException caught");
        }
    }
            
    Console.WriteLine("That's all, folks!");
}
```

- [ ] ??? У меня это не сработало, прога ложилась. Посмотреть потом, в чем дело.

Было ли исключение, можно также узнать по свойствам `isFaulted` и `isCancelled`. Если оба они `false`, то исключений не было. Если `isCancelled == true`, значит задача была отменена (при этом выбрасывается `OperationCanceledException`), а если `isFaulted == true`, значит было другое исключение и его можно узнать по свойству `Exception`.

Задачи, которых не ожидают и от которых не нужен результат, называются *автономными*. Обработку исключений  нужно писать прямо внутри таких задачи, потому что несмотря на то, что их не дожидаются, исключение никуда не пропадет, а выбросится в момент, когда объект задачи выйдет из области видимости и CLR будет выполнять поток финализаторов. Этот момент может быть очень далеко от момента реального возникновения ошибки и программа будет ложится казалось бы в весьма неочевидный момент.

## Продолжения

Продолжения - это способ после завершения одной задачи сразу же выполнить другую, то есть организовать цепочку задач. Есть несколько способов, вот олдовый, через объект ожидания:

```c#
static void Main(string[] args)
{
    TaskAwaiter<int> awt = Task.Run(() =>
        {
            Thread.Sleep(3000);
            return 5;
        }
    ).GetAwaiter();

    awt.OnCompleted(() => { Console.WriteLine(awt.GetResult()); });
            
    while (!awt.IsCompleted) { }

    Console.WriteLine("That's all, folks!");
}
```

Из каждой задачи можно достать объект ожидания. У него есть ряд полезных методов, среди которых:

* `OnCompleted(action)` - как показано в примере, принимает делегат, который выполняется сразу по завершении задачи. Напрямую через него чейнить не особо удобно.
* `GetResult()` - метод возвращает результат. Если задача ничего не возвращает, то и этот метод тоже ничего не возвращает. Этот метод хорош тем, что если в задаче было исключение, то при обращении к этому методу  оно не будет обернуто в `AggregateException` и блоки catch будут выглядеть аккуратнее.
* `IsCompeted` - свойство, позволяет понять, завершена ли задача

Второй способ:

```c#
static void Main(string[] args)
{
    Task<int> t1 = Task.Run(() =>
        {
            Thread.Sleep(3000);
            return 7;
        }
    );

    t1.ContinueWith(prev => { Console.WriteLine(prev.Result); })
        .ContinueWith(prev => { Console.WriteLine("The end"); });
            
    while (!t1.IsCompleted) { }

    Console.WriteLine("That's all, folks!");
}
```

Через `ContinueWith` гораздо удобнее чейнить задачи, потому что он тоже возвращает задачу.

??? Есть вот такой код, который как-то связан с настройкой, в каком потоке будет выполняться продолжение - в том же самом или в другом. Но как именно это работает - из книги не понятно. Догуглить отдельно:

```c#
var awt = someTask.ConfigureAwait(false).GetAwaiter();
```

- [ ] ??? Вопрос, в каком потоке будет выполняться продолжение - в том же, или в другом - неоднозначный. На стр. 580 об этом немного упомянуто, но совсем вскользь.

## TaskCompletionSource

```c#
using System.Runtime.CompilerServices;
```

С помощью объекта `TaskCompletionSource` можно получить удобства задач, но при этом работать в потоке не из пула:

```c#
static void Main(string[] args)
{
    var tcs = new TaskCompletionSource<int>();

    new Thread(() => { Thread.Sleep(3000); tcs.SetResult(7); }).Start();
            
    Console.WriteLine((tcs.Task).Result);
    Console.WriteLine("That's all, folks!");
}
```

Создается TCS и замыкается в потоке. Теперь внутри потока можно использовать методы:

```c#
void SetResult(TRes);
void SetException(Exception);
void SetCanceled();
bool TrySetResult(TRes);
bool TrySetException(Exception);
bool TrySetCanceled();
bool TrySetCanceled(CancellationToken);
```

для организации нужного действия - установки в качестве результата, собственно, результата, или исключения, или вообще отмену. Каждый метод можно вызвать только единожды, поэтому есть дубликаты с try.

Пример как самому сделать нечто похожее на `Task.Factory.StartNew(, TaskCreationOptions.LongRunning)`:

```c#
static void Main(string[] args)
{
    var res = Run(() => { int a = 0; while (a < 1000) a++; return a; }).Result;
    Console.WriteLine(res);
    Console.WriteLine("That's all, folks!");
}

// Объявление типа TRes в Run<> делает его понятным для использования в других частях сигнатуры
static Task<TRes> Run<TRes>(Func<TRes> work)
{
    var tcs = new TaskCompletionSource<TRes>();

    new Thread(() => {
        try { tcs.SetResult(work()); }
        catch (Exception ex) { tcs.SetException(ex);  }
    }).Start();

    return tcs.Task;
}
```

## Асинхронность

*Синхронные* методы сначала полностью выполняются, а потом возвращают управление вызывающему коду. *Асинхронные* методы сначала возвращают управление, а потом начинают выполнение, параллельно с вызывающим кодом.

Практическое правило - выполнять асинхронно все операции, длящиеся больше 50 милисекунд.

Если представить всю цепочку вызовов в виде графа, то асинхронность нужно использовать на самом нижнем уровне. Так будет реализовываться *мелкомодульный параллелизм*, то есть асинхронно будут выполняться только те участки кода, которым это действительно нужно, а не целый граф (тогда это был бы *крупномодульный палаллелизм*).

## await / async

await упрощает присоединение продолжения к задаче. Например, хотим асинхронно вернуть пятерку, а потом вывести ее в консоль. Вариант без `async` предполагает ручное присоединение продолжения:

```c#
static void Main(string[] args)
{
    var tsk = FooAsync();
    var awt = tsk.GetAwaiter();
    awt.OnCompleted(() =>
    {
        var result = awt.GetResult();
        Console.WriteLine(result);
    });
    
    /* Или вот так
    var tsk = FooAsync()
    	.ContinueWith(t => Console.WriteLine(t.Result));
    */

    tsk.Wait();
    Console.WriteLine("That's all, folks!");
}

static Task<int> FooAsync()
{
    return Task.Run(() => { Thread.Sleep(3000); return 5; });
}
```

С `await` это выглядит так:

```c#
static void Main(string[] args)
{
    AsyncAwaitDemo();

    Thread.Sleep(4000);
    Console.WriteLine("That's all, folks!");
}

async static void AsyncAwaitDemo()
{
    int result = await FooAsync();  // управление возвращается вызывающему коду
    Console.WriteLine(result);
}

static Task<int> FooAsync()
{
    return Task.Run(() => { Thread.Sleep(2000); return 5; });
}
```

await **не приводит** к тому, что процесс блокируется, пока задача не выполнится. await просто помещает код, идущий за ним и до конца функции, в продолжение задачи. То есть к задаче, которую вернул метод `FooAsync`, присоединяется продолжение с командой `Console.WriteLine(result)`. Поскольку задачи запускаются в фоновых потоках из пула, я добавил в `Main` блокирование на 4с, чтобы увидеть результат.

`async` нужен просто для того, чтобы слово await воспринималось как ключевое, а не как идентификатор.

await без проблем используется в любых местах (кроме lock, unsafe и Main), например в циклах:

```c#
static void Main(string[] args)
{
    AsyncAwaitDemo();

    Thread.Sleep(10000);
    Console.WriteLine("That's all, folks!");
}

async static void AsyncAwaitDemo()
{
    for (var i = 0; i < 10; i++)
    {
        await FooAsync(i);
        Console.WriteLine("cycle i: {0}", i);
    }
}

static Task FooAsync(int value)
{
    return Task.Run(() => { 
        if (value == 5) Thread.Sleep(5000);
        else Thread.Sleep(300);
        Console.WriteLine(value); 
    });
}
```

В консоль выведутся цифры с 0 по 9. То есть с локальными значениями никаких проблем нет.

- [ ] ??? Вообще я ожидал, что 5 выведется последней, но очередность сохранилась. Почему? Может быть потому что CLR поставила все эти задачи в одну очередь?

## void или Task?

(стр. 594 Албахари) Если есть асинхронный метод, то можно оформить его вызов так, чтобы и вызывающий метод тоже можно было ожидать. Пример:

```c#
static void Main(string[] args)
{
    AsyncNotVoidDemo();

    Thread.Sleep(4000);
    Console.WriteLine("That's all, folks!");
}

static async void AsyncNotVoidCall()
{
    await AsyncNotVoid();
    Console.WriteLine("Метод, вызывающий этот Async, тоже отработал");
}

static async Task AsyncNotVoid()  // Тип Task, но задачу не возвращает
{
    await Task.Run(() => Thread.Sleep(2000));
    Console.WriteLine("Async метод отработал");
}
```

Метод `AsyncNotVoid` не возвращает задачу, но тип у него Task. Это позволяет дожидаться его самого - в методе `AsyncNotVoidCall`. Компилятор добавляет в функции, которые имеют тип Task (но при этом не возвращают задачу), объект `TaskCompletionSource`. Оформляет продолжение, помещает await-код в блок try-catch, устанавливает исключение, результат. Пример:

```c#
Task PrintAnswer()
{
    var tcs = new TaskCompletionSource<object>();
    // То что мы await'им в предыдущем примере - здесь:
    var awt = Task.Run(() => Thread.Sleep(2000)).GetAwaiter();  // <--
    awn.OnCompleted(() => {
        try 
        { 
            awt.GetResult();  // Получаем результат работы или исключение
            Console.WriteLine("Async метод отработал");  // Все, что было после await - тут
            tsc.SetResult(null);  // Метод не возвращал результата изначально, так что null
        }
        catch (Exception ex) { tcs.SetException(ex); }
    });
    return tsc.Task();
}
```

Можно типизировать возврат, например, `Task<int>`. Тогда все будет то же самое, только в `SetResult` поставится не null, а реальное значение.

То же самое можно сделать с лямбдой. Зачем нужно ??? честно говоря пока не особо понял. Пишут, что вроде как удобно развешивать асинхронные обработчики:

```c#
Func<Task> PrintAnswer = async () =>
{
    await Task.Run(() => Thread.Sleep(2000));
    Console.WriteLine("Async метод отработал");
};
```

## Синхронное завершение

Если асинхронная операция успевает завершиться до того, как используется результат, то await не приводит к возврату в вызывающий код, а все выполняется синхронно.

Рассмотрим такую функцию:

```c#
Dictionary<string, string> _cache = new Dictionary<string, string> _cache();
...
async Task<string> GetWebPageAsync(string uri)
{
    string html;
    if (_cache.TryGetValue(uri, out html))
        return html;  // Можно явно Task.FromResult(html);
    return _cache[uri] = await new WebClient().DownloadStringTaskAsync(uri);
}
```

В ней может оказаться, что страница уже есть в кэше, а значит нет нужды организовывать асинхронную загрузку. С виду мы возвращает просто string, но компилятор оформляет это в задачу с установленным признаком завершения `IsCompleted`.

Таким образом, если задача к моменту ожидания уже выполнена:

```c#
Console.WriteLine(await GetWebPageAsync("http:/oreilly.com"));  // Есть в кэше
```

то нет смысла передавать управление вызывающему коду, чтобы по сути сразу вернуться к выполнению продолжения. Для этого компилятор преобразует такие вызовы следующим образом:

```c#
var awt = GetWebPageAsync("http:/oreilly.com").GetAwaiter();
if (awt.IsCompleted)
    Console.WriteLine(awt.GetResult());
else
    awt.OnCompleted(() => Console.WriteLine(awt.GetResult()));
```

- [ ] ??? Интересно, а такие условия компилятор генерирует только когда явно видит, что из функции возвращается не задача?
- [ ] ??? Пытался представить, во что развернется этот await new WebClient(), но не получилось. Потом можно будет подумать. Так-то понятно как это работает, но было бы интересно узнать во что это развернется.

В этом примере потенциально может быть активировано несколько загрузок одной и той же страницы. Если страница грузится довольно долго, то и результат появится в кеше не скоро, а значит запустив несколько задач, они не будут знать, что уже идет загрузка. В итоге в кэш поместится результат работы последней задачи, а все остальные загрузки были избыточны.

Но в словарь вместо страницы можно поместить *саму задачу*:

```c#
Dictionary<string, Task<string>> _cache = new Dictionary<string, Task<string>> _cache();
...
async Task<string> GetWebPageAsync(string uri)
{
    Task<string> downloadTask;
    if (_cache.TryGetValue(uri, out downloadTask))
        return downloadTask;
    return _cache[uri] = new WebClient().DownloadStringTaskAsync(uri);
}
```

Можно улучшить пример и добавить `lock`:

```c#
async Task<string> GetWebPageAsync(string uri)
{
    lock (_cache)
    {
        Task<string> downloadTask;
        if (_cache.TryGetValue(uri, out downloadTask))
            return downloadTask;
        return _cache[uri] = new WebClient().DownloadStringTaskAsync(uri);
    }
}
```

Эффективность заключается в том, что загрузка все равно происходит параллельно, а кэш блокируется только на короткое время проверки\помещения в него задачи.

# Асинхронные шаблоны

В .NET полно асинхронных функций, реализующих шаблон **TAP** (Task-based Asyncronous Pattern). У них в названии есть суффикс *Async*. Для них характерны следующие вещи:

* Поддерживают отмену и сообщение о ходе работ, для чего существуют перегруженные методы
* Быстро передают управление обратно колеру, возвращая горячие задачи, с минимальной задержкой
* Не связывают (??? что это значит) потоки, если операция является интенсивным IO

## Отмена работы

Для реализации шаблона отмены используется пара объектов `CancellationTokenSource` и `CancellationToken`. С помощью первого генерируется токен и передается в функцию, в которой предполагается возможность отмены. Когда нужно сделать отмену, на сорсе вызывается метод `Cancel()` и в токене из-за этого устанавливается свойство `IsCancellationRequested = true`. Можно его проверить и организовать отмену. В конструктор `cts` можно передать время, через которое отмена сгенерируются автоматически.

Такая организация сделана для того, чтобы функция не могла сама себя отменить, а только проверить, не запросил ли колер отмену.

У токена есть метод `Register`, который позволяет задать обработчики отмены.

`OperationCancelledException` - стандартное исключение из неймспейса `System`, использующееся при отмене работы.

Запрос отмены распространяется *вверх по стеку*, а исключение распространяется *вниз по стеку* (хотя тут спорно, что называть низом, что верхом. Я под низом имею ввиду самую первую вызванную функцию):

```c#
static async Task Foo(CancellationToken ctok)
{
    await Task.Run(() => Thread.Sleep(3000));
    if (ctok.IsCancellationRequested) throw new OperationCanceledException();
    Console.WriteLine("Первая задача выполнена");

    await Task.Run(() => Thread.Sleep(4000));
    if (ctok.IsCancellationRequested) throw new OperationCanceledException();
    Console.WriteLine("Вторая задача выполнена");
}

static async void CancellationDemo(CancellationToken ctok)
{
    try 
    { 
        ctok.Register(() => Console.WriteLine("Обработчик отмены")); 
        await Foo(ctok); 
    }
    catch (OperationCancelledException ex) { Console.WriteLine("Работа отменена"); };
    Console.WriteLine("CancellationDemo отработал");
}

static void Main(string[] args)
{
    var cts = new CancellationTokenSource();  // (3500), тогда вторая работа не выполлнится
    CancellationDemo(cts.Token);
    cts.Cancel();

    Thread.Sleep(8000);
    Console.WriteLine("That's all, folks!");
}
```

Многие асинхронные функции CLR поддерживают отмену.

## Сообщение о ходе работ

В случае, когда имеет значение контекст синхронизации, например, в приложениях с GUI, нужно использовать специальный класс `Progress`, который автоматически захватывает КС и поэтому вызов делегата является потокобезопасным:

```c#
static async Task CountToBillion(IProgress<int> progress)
{
    int cnt = 0;

    await Task.Run(() =>
    {
        while (cnt < 1_000)
        {
            Thread.Sleep(1);
            cnt++;
            if (cnt % 100 == 0) progress.Report(cnt);
        }
    });
}

static void Main(string[] args)
{
    var progress = new Progress<int>(value => Console.WriteLine(value));
    CountToBillion(progress);

    Thread.Sleep(20_000);
    Console.WriteLine("That's all, folks!");
}
```

