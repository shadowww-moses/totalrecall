

# Идеи, вопросы

* Нужно придумать, как коммитить в одиночку из-под разных пользователей, чтобы имитировать командную разработку. 

  Тогда можно будет проверить, что происходит, если другой человек добавил в репо коммиты, а я их вытянул - они будут под моими или может расположатся вперемешку в зависимости от времени и т.д.

  Есть возможность пуллить вот так `git pull --rebase`, так что становится еще интереснее очередность коммитов, выпулленных разными способами.

* Как отразится на других участниках, если сделать amend на уже запушенной ветке и снова запушить?

* Если есть две ветки и в одну из них напрямую сделать коммит с изменением, то это изменение навсегда останется "конфликтным" между двумя ветками?



# Более глобальные идеи

* Посмотреть как самостоятельно захостить Gitlab, настраивать ci/cd

# Заметки

Настройки и ssh https://ru.hexlet.io/courses/intro_to_git/lessons/setup/theory_unit

Список всех допов к урокам https://ru.hexlet.io/courses/intro_to_git/extra_materials

Коммитить построчно можно через VS Code с плагином `git lens`

# Терминология

* **Индекс** - он же **Stage**.

* **Репозиторий** и **Рабочая Директория**

  Репозиторий - это то, что лежит в папке .git Тут содержится история изменений и сами изменения.

  Рабочая директория - это папка с файлами проекта (за исключением папки .git) в текущем виде.



# Концепции

* Git - распределенная система. Это значит, что нигде нет какого-то "центрального" репозитория. Как на github, так и у каждого разработчика лежат полноценные самостоятельные версии репо. Связь между ними git понимает на основании истории коммитов, поэтому важно не нарушить ее.

* Git работает по принципу односвязного списка. Каждый коммит - это элемент списка, имеющий ссылку только на предыдущий элемент. Последний добавленный в список элемент называется HEAD.

  При работе используется много списков, которые переплетаются друг с другом. Каждая ветка - по сути отдельный список, который начинается от какого-то коммита другого списка и дальше развивается самостоятельно. Имя ветки - это указатель на последний элемент этого самостоятельного списка. Когда вы переключаетесь на ветку, то HEAD начинает указывает на последний элемент этой ветки.



# Команды

Каждую команду оформить отдельным параграфом и снабдить скринами консоли.

Команды распределить по категориям, например, на данный момент я вижу категорию "информационные", типа blame, log, и "модифицирующие", типа reset, revert и "управляющие" да даже commit, add, restore

https://ru.hexlet.io/courses/intro_to_git/lessons/commits-cancelation/theory_unit

* `git commit --amend --no-edit` - используется, когда не хочется создавать новый коммит, а нужно именно приделать что-то к последнему коммиту. На деле, выполняет reset последнего коммита и создает новый, поэтому операцию можно использовать, только если "изменяемый" коммит еще не запушен, иначе сломается история. Флаг --no-edit говорит взять описание старого коммита для нового. 

  Проверить, раз он создает новый, значит хэш коммита должен измениться.

* `git add`

  `.` - добавить все файлы из рабочей директории в коммит

  `filename.c` - добавить только указанный файл (проверить, как добавить несколько - через запятую например, или просто через пробел)

  `-am "Добавил все и сразу закоммитил"` - добавляет все файлы в индекс и сразу коммитит

  `-i` - интерактивное добавление, он же "частичный коммит", когда в одном файле много изменений и в коммит надо включить только какую-то их часть. Тут в консоли выглядит сложно, надо отдельно проверить

* `git rm` - удаление файла или директории. Загуглить отдельно, что значит удаление - с диска или что

* `git restore` - для восстановления файла, если еще не сделан коммит. Причем под восстановлением понимается и восстановление файла на диске в рабочей директории, если он был удален, и восстановление его содержимого (т.е. отмена внесенных и еще не закоммиченных изменений). 

  Опция `--staged` используется, если делается restore для файла в индексе ("помещенного в stage"). При этом  он убирается из индекса, но в нем остаются изменения. Для их отката нужно еще раз сделать restore (проверить).

* `git diff` - посмотреть изменения во всех файлах, кроме добавленных в индекс (опция `--staged` чтобы посмотреть индексные (проверить, только ли индексные или все + индексные))

* `git log` - история всех коммитов. 

  `-p` - выводит diff для каждого коммита

  `--oneline` - сокращенный формат вывода. Проверить, выводится ли только первая строчка комментария, и если да, то полностью, если она очень длинная, или частично

  `--graph` - выводит псевдографическое дерево

* `git show HashКоммита` - показывает изменения, внесенные указанным коммитом. Достаточно первых 8 символов хэша

* `git blame ПутьДоФайла` - выводит информацию для каждой строки файла, кто и в каком коммите трогал ее в последний раз (кто добавил или кто редактировал). Работает из ПКМ в VS кстати.

  Если запускать через консоль, вывод будет большим - листать вперед кнопкой `f`, назад `b`, выйти `q`

* `git grep` - поиск в файлах, с учетом того, что это гит - не ищет в .git, в игнорируемых файлах и т.д. Требует отдельного гугления как пользоваться

* `git clean -fd` - удалить файлы и директории, которые были созданы, но не закоммичены. -f значит force (а не file), -d - directory

  Проверить, сработает ли, если сначала добавить файлы в индекс
  
* `git revert` - отменяет изменения, внесенные указанным коммитом, создавая новый коммит-"наоборот". Можно ли указать сразу несколько коммитов этой команде?

  Проверить, можно ли указывать сразу несколько коммитов

* `git reset` - удаляет коммит. Что будет с изменениями из коммита - зависит от флага:

  `--hard HEAD~2` - 2 коммита от текущего удаляются, изменения удаляются окончательно. HEAD - указатель на текущий коммит

  ​	Что будет, если перейти на произвольный коммит и сделать ресет?

  `--soft` - коммит удаляется, а изменения попадают в индекс. Их можно снова закоммитить, а можно с помощью restore вытащить в рабочую директорию и там через еще один restore отменить. Пример для наглядности: удаляем все из файла конфига, коммитим. Делаем reset --soft, теперь коммит удален, а пустой файл оказывается в индексе. Делаем restore и файл оказывается в рабочей директории. Делаем еще раз restore и содержимое файла восстанавливается до состояния, которое было перед коммитом с удалением
  
  `--mixed` - флаг по умолчанию. Проверить, куда поместятся изменения. Теоретически, должны сразу в рабочую директорию
  
* `git checkout e45df` - загрузить в рабочую директорию содержимое указанного коммита ("переключиться на произвольный коммит по его хэшу"). Файлы в рабочей директории примут вид, который был при этом коммите

  `git checkout main` - вернуться на последний коммит. Что это за последний коммит и что такое main, сказали будет дальше, не забыть поправить. Походу это просто имя ветки

  `git switch -` - вообще хз что это за команда, но походу то же самый эффект как у git checkout main

  Все это про одно - нахождение в состоянии detached HEAD и как из него выйти

  алсо проверить, что будет, если в detached HEAD закоммитить что-то

* `git branch` - если набрать без всего, то покажет, на какой ветке (или коммите) мы сейчас находимся

* `git stash` - если работаете над чем-то и нужно вдруг переключиться на другую ветку, то наличие в рабочей директории изменений не позволит сделать это. git stash позволяет все изменения перенести в "тайник", "стэш", очистив рабочую директорию от изменений, потом переключиться на другую ветку, сделать там все что нужно, а потом вернуться в исходную ветку, вытащить все из тайника обратно и продолжить работу.

  `git stash pop` - вытащить из тайника

  Стэшить можно несколько раз, но извлекать тоже тогда придется несколько раз. Правда не совсем понятно зачем может понадобиться стэшить несколько раз, но можно проверить



# .gitingnore

В отдельном разделе написать про маски игнорирования

Немного:

* `debug.log` - игнорирование этого файла в любом месте репо

* `logs` - игнорирование этой директории в любом месте репо

* `/bin` - игнорирование этой директории только в корне репо. В любом другом месте она не будет игнорироваться

* `/db/*.tmp` - игнорировать любые файлы с расширением .tmp в директории db. При этом например в /db/sql/logs.tmp - игнорироваться не будет

  `/db/**/*.tmp` - игнорировать .tmp файлы в директории db и вложенных в нее

  Проверить, тут /db тоже означает только корень репо? Если будет директория /foo/db, то в ней будет работать игнорирование?