# Идея

Основная идея Redux - централизованное хранилище состояния приложения (состояние - синоним слова "данные"), к которому можно получить доступ из любого компонента и достать нужные данные. Благодаря этому отпадает необходимость поднимать состояние вверх до первого общего родительского компонента и прокидывать вниз через пропсы, если одинаковые данные нужны в разных ветках приложения. Красным показаны компоненты, в которых эти данные не нужны, но вынуждены помещаться туда исключительно из-за того, что их надо прокинуть дальше по дереву компонентов.

<img src="img\image-20200529105416325.png" alt="image-20200529105416325" style="zoom:80%;" />

Таким образом, пропсы компонентов не засоряются данными, которые им даже не нужны, но передаются исключительно чтобы прокинуть их дальше вниз в реально нужное место.

Основные игроки Redux - это **хранилище**, **экшены** и **редюсеры**.

* Хранилище - это объект, хранящий состояние приложения. Компоненты могут подключаться к хранилищу и получать нужные им данные. Хранилище позволяет кэшировать получаемые данные и не делать повторных запросов на сервер. А еще оно позволяет сохранять состояние на сервер и при повторном запуске загружать его, таким образом формируя сессии работы.
* Экшены - это "аватары" доступных в приложении операций. Аватары - потому что они обычно не выполняют никаких непосредственных действий, а просто возвращают объект определенной структуры, таким образом просто как бы символизируя то, что в приложении инициировалось какое-то действие
* Редюсеры - вот те работяги, которые вычисляют новое состояние приложения на основе пришедших к ним данных. Именно вычисляют и возвращают новое, потому что изменять (мутировать) состояние нельзя, можно только вычислить новое и вернуть его целиком. А данные к ним приходят как раз в составе экшена

Основной флоу выглядит так:

* Приложение диспатчит экшен, передавая с ним нагрузку (какие-то данные). Диспатчит - означает регистрирует особым образом возникновение действия, так чтобы на него могли отреагировать редюсеры
* Экшен проваливается в трубу редюсеров и падает по ней через все редюсеры. Каждый редюсер проверяет тип экшена и принимает решение, надо ли что-то делать, как-то обрабатывать
* Обработка заключается в том, что редюсер берет нагрузку, пришедшую с экшеном, вычисляет новое состояние приложения и заменяет старое новым
* Все React-компоненты, которые затронуло это изменение, обновляются

Это грубое объяснение, но суть оно отражает. Дальше идут примеры и детализация идей.

<img src="img\image-20200529165640421.png" alt="image-20200529165640421" style="zoom:80%;" />



# Redux и React-Redux

Redux - это, грубо говоря, самостоятельная технология, не привязанная к реакту. Может использоваться и с Angular например. А React-Redux - это библиотека, которая помогает использовать Redux именно в React-приложениях, беря на себя всю рутину вроде оформления\снятия подписки, оповещения компонентов об изменении стейта хранилища и т.д.

Зная это, уже можно будет догадаться, глядя на примеры, почему например функция combineReducers импортируется из redux, а connect - из react-redux.



# No async пример

В, так сказать, "базовом" виде Redux работает только в синхронном режиме. То есть, когда диспатчится экшен, сразу происходит вычисление нового состояния. Использовать в экшенах асинхронные методы вроде fetch не получится. Для этого придется использовать миддлвари. Это будет в следующем примере Async.

В этом приложении мы добавляем игры в список и отмечаем, пройдена игра или нет. Еще можно включать\выключать показ пройденных игр.

## Главный файл приложения

Здесь создается хранилище нашим методом configureStore (будет показан дальше). Созданное хранилище передаем компоненту Provider и заворачиваем в этот провайдер приложение. Таким образом, хранилище становится доступным компоненту приложения и впоследствии мы сможем присоединять и другие компоненты к хранилищу.

<img src="img\image-20200529113528405.png" alt="image-20200529113528405" style="zoom:80%;" />

## Конфигурирование хранилища

Наш метод конфигурации хранилища. Здесь мы создаем хранилище редаксовым методом `createStore`. Ему надо передать как минимум `корневой редюсер`. Второй параметр - начальное состояние хранилища, третий - набор миддлварей. В этом простом примере достаточно только редюсера.

<img src="img\image-20200529114836603.png" alt="image-20200529114836603" style="zoom:80%;" />

С передачей начального состояния надо быть осторожным. Если что-то передать, хоть null, хоть пустой объект {}, тогда может не сработать значение стейта по умолчанию в параметрах редюсеров. Возможно это только если не использовать combineReducers, но короче я сейчас точно это не знаю, но надо осторожнее. Если вдруг косяки с состоянием, что-то не видится, ошибку можно искать в этом месте.

## Экшены

Экшены - это "аватары" операций, которые могут происходить в приложении. Это не полноценные операции в том плане, что они ничего не делают (по крайней мере, в этом примере не делают, а в Async будут делать, но это уже другая история). 

Экшены - это просто объекты, у которых обязательно есть поле `type`, а дальше может идти нагрузка, т.е. данные, которые сопутствуют действию.

<img src="img\image-20200529120037013.png" alt="image-20200529120037013" style="zoom:80%;" />

Такие функции называются `action creators`, то есть "создатели действий". А непосредственно действия - это объекты, возвращаемые этими функциями. Как было сказано, с действием может идти нагрузка, а может и не идти. Например, в toggleDoneVisibility нагрузки нет. В gameAdd нагрузка - название игры, а в gameDoneToggle - id игры, которую надо пометить как пройденную. Нагрузка может состоять не только из одного параметра, но и из нескольких.

Типы действий - обычные строки. Их удобно оформлять в отдельном файле в виде констант и потом импортировать. Так минимизируется вероятность опечатки:

<img src="img\image-20200529120015346.png" alt="image-20200529120015346" style="zoom:80%;" />

## Редюсеры

Редюсеры - это работяги, которые реагируют на экшены. Они принимают текущий стейт, экшен, и вычисляют новое значение стейта с учетом нагрузки, пришедшей с экшеном.

Важно обозначить `шейп` стейта (initState). Сейчас мне уже кажется это надо больше для того, чтобы самому лучше ориентироваться, как вообще выглядит стейт и не запутаться в редюсерах.

<img src="img\image-20200529135946971.png" alt="image-20200529135946971" style="zoom:80%;" />

* Редюсер как явление - суть функция, которая принимает стейт и экшен
* Редюсеров много, потому что так проще: если каждый из них формирует только определенную часть стейта, то это проще, чем формировать целиковый стейт за раз
* Из всех этих кусочков нужно собрать целиковый стейт. Это задача корневого редюсера
* Корневой редюсер объединяет все редюсеры и, поскольку каждый из них возвращает кусочек стейта, то в итоге получается целиковый стейт

На этом скрине показано формирование КР с помощью редаксовой функции combineReducers. Работает все так:

* В combineReducers передаем объект, каждое поле которого - отдельный редюсер

* Обрати внимание на подсветку: поля корневого редюсера, функции-редюсеры и куски стейта называются одинаково неспроста

  > В combineReducers используется shorthand-синтаксис. По-хорошему надо было бы писать hideDone: hideDone, games: games, т.е. имя поля: значение. Но поскольку название поля и его значение называются одинаково, можно писать просто hideDone и games

* Благодаря этому combineReducers понимает, какую часть стейта возвращает каждый редюсер (дальше еще будет показано как все это написать руками). Допустим, функция-редюсер hideDone возвращает объект, который попадет в итоговый стейт под именем hideDone. А редюсер games вернет объект, который поместится в поле games. Итого получим объект с полями hideDone и games - как раз наш объект стейта, обрисованный в начале файла

Важно помнить, что мутировать стейт нельзя. Поэтому внимательно посмотри как написано вычисление нового стейта через оператор спред и обходы массива.

Итого: экшен проходит через ВСЕ редюсеры. Если редюсер как-то должен реагировать на экшен, то он вычисляет новый фрагмент стейта и возвращает этот фрагмент. Если не должен реагировать, то редюсер возвращает дефолтное значение этого фрагмента. Таким образом, "с мира по нитке - голому рубаха" - каждый редюсер вернет по мини-фрагменту, из которых в итоге на выходе из корневого редюсера выйдет целиковый стейт.

### Ручное написание КР

Начальный стейт:

<img src="img\image-20200529171828889.png" alt="image-20200529171828889" style="zoom:80%;" />

<p align="center">[ Шаг 1 ]</p>

Пишем единый всеобъемлющий редюсер. Он принимает инит стейт и каждый кейс возвращает стейс целиком:

<img src="img\image-20200529171936248.png" alt="image-20200529171936248" style="zoom:80%;" />

<p align="center">[ Шаг 2 ]</p>

Прикидываем, какую часть стейта каждый кейс действительно затрагивает и выделяем отдельные функции-редюсеры, которые с этой частью работают. Из корневого редюсера в микроредюсеры передаем только эту часть. В КР по-прежнему возвращается объект, поля которого называются как части стейта. Этот КР передаем в хранилище при его создании.

<img src="img\image-20200529172150238.png" alt="image-20200529172150238" style="zoom:80%;" />

<img src="img\image-20200529172208813.png" alt="image-20200529172208813" style="zoom:80%;" />

<img src="G:\Documents\typora\NextLevel\React-Redux\React-Redux - Основы\img\image-20200529172324502.png" alt="image-20200529172324502" style="zoom:80%;" />



## Компонент-контейнер

Таким образом, к данному моменту у нас получилось 

* Хранилище со стейтом определенного шейпа
* Экшены - "символические" операции приложения
* Редюсеры - работяги, которые ориентируясь на нагрузку экшенов вычисляют новый стейт

Теперь надо это как-то использовать в приложении. Для этого нужно подключить компонент к хранилищу. Это делается функцией `connect`

<img src="img\image-20200529144019584.png" alt="image-20200529144019584" style="zoom:80%;" />

Этот компонент называется контейнером, потому что он суть - мозги. В нем мы и подключаемся к хранилищу, и формируем функции-обработчики, которые потом передаем в презентационный компонент `GameListView`. В общем, выполняем всю умную движуху.

`connect` принимает две функции - `mapStateToProps` и `mapDispatchToProps`. Она передаем им, соответственно, стейт и специальную функцию `dispatch`, которая предназначена для регистрации экшена. В итоге connect тоже возвращает функцию, в которую мы уже передаем наш компонент `GameListContainer` и в нем становится доступна часть стейта и функции, которые мы объявили.

В целом, я не знаю, как тут это объяснять. Это очень сложно как-то сделать. Поэтому я и писал этот пример. Он минималистичный и глядя на код и понимая идею в целом все должно быть понятно.

* У нас уже есть хранилище со стейтом. Нашему компоненту GameListContainer нужен не весь стейт, а какая-то его часть. В данном примере он конечно всем стейтом пользуется, но это потому что пример крошечный
* Поэтому мы хотим открыть компоненту только ту часть стейта, которая ему нужна и не грузить ничем лишним
* Для этого мы объявляем функцию mapStateToProps и передаем ее в connect
* Connect в свою очередь передает ей целиковый стейт
* Пользуясь этим целиковым стейтом, мы из mapStateToProps возвращаем объект, содержащий только ту часть стейта, которая нужна компоненту

Как повлиять на стейт приложения? Нужно зарегистрировать экшен и передать нагрузку. Тогда экшен с ней провалится по редюсерам и какой-то из них них вычислит новый стейт. Зарегистрировать - иначе говоря - задиспачить. Это делается функцией хранилища `dispatch`. Чтобы получить доступ к этой функции, мы:

* Создаем функцию mapDispatchToProps и передаем ее в функцию connect
* Connect передает в нее функцию dispatch через параметр
* Мы возвращаем из mapDispatchToProps объект, каждое поле которого содержит функцию, которая диспатчит опеределенный экшен и передает в него нагрузку

Далее все это добро, возвращаемое этими mapStateToProps и mapDispatchToProps - кусок стейта и функции, диспачащие экшены - попадает в пропсы подключаемого компонента и может быть внутри него использовано.

## Компонент-презентер

Ну и наконец компонент, которому остается только отобразить все, что мы понавыбирали в контейнере:

<img src="img\image-20200529151620720.png" alt="image-20200529151620720" style="zoom:80%;" />



# Async пример

Если в приложении требуется использовать асинхронные операции, например, с помощью fetch посылать AJAX-запросы на сервер за данными, тогда при создании хранилища надо задействовать миддлвари

## Middleware

Применительно к Redux, миддварь - это слой ПО, вклинивающийся во флоу между моментом диспачинга экшена и моментом провала этого экшена в трубу редюсеров.

> [Из официального руководства:](https://redux.js.org/advanced/middleware)
>
> Redux middleware solves different problems than Express or Koa middleware, but in a conceptually similar way. **It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.** People use Redux middleware for logging, crash reporting, talking to an asynchronous API, routing, and more.

Я не буду даже пытаться объяснить как это работает под капотом, потому что не понимаю этого до конца. Но все-таки некоторые заметки сделаю, которые помогают мне сейчас как-то это осознавать.

Что такое экшен, а точнее, action creator? Он должен иметь определенный формат - возвращать объект, иначе dispatch его не воспримет. И вот допустим у нас есть действие "Получить список сотрудников". И этот список был бы нагрузкой для экшена. Но списка-то нет, его надо сначала через fetch получить. А где получать? Если в action creator нельзя, потому что это нарушит его формат, то значит надо получать где-то в приложении. А тогда получается полная чушь, потому что это ведет к децентрализации логики. Потому что по-хорошему надо в компоненты уже все готовое по сути передавать. Значит, надо все-таки в action creator делать fetch.

И вот тут на арену выходит новый вид экшена:

<img src="img\image-20200529181908386.png" alt="image-20200529181908386" style="zoom:80%;" />

Экшен, который суть не объект, а функция, требующая dispatch. Так я это и запомнил - два вида экшенов. Если надо в экшене предварительно достать данные откуда-то, значит просто используем второй тип. А миддлварь позаботится о том, чтобы наш экшен-функция получил dispatch.

Как это выглядит в коде?

## thunk

Миддлварь, которая нам нужна, называется `thunk`. Устанавливаем ее в проект `npm install thunk`

Применяется она следующим образом:

<img src="img\image-20200529182836723.png" alt="image-20200529182836723" style="zoom:80%;" />

Со вторым параметром createStore, который суть начальное состояние хранилища, надо быть осторожнее, как я писал раньше в разделе "Конфигурирование хранилища".

Теперь вот как создается этот самый второй тип экшена:

<img src="img\image-20200529183718878.png" alt="image-20200529183718878" style="zoom:80%;" />

Здесь видно на контрасте два типа экшенов: первый асинхронный, а два следующих - синхронные. Таким образом, асинхронный экшен - это получается комбинация диспатча синхронных экшенов и вызов асинхронных функций. То есть мы сначала диспатчим синхронный employeeGetallStart, который при обработке например выставит какой-нибудь isFetching в true, затем делаем fetch и по возврату данных уже вызываем синхронный employeesGetallSuccess, который, провалившись в редюсер, приведет к выставлению isFetching в false и добавлению загруженных данных в хранилище.