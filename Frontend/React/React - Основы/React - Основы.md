# Что внести

- [ ] Нужно разобраться как формировать query string. Пока что умею только id передавать как часть пути
- [ ] 



# import и export

## Общий принцип

<img src="img\image-20200515102105435.png" alt="image-20200515102105435" style="zoom:80%;" />

* Экспортировать можно через `export` и `export default`

* Экспортировать можно сразу при объявлении или отдельно. Причем неважно, в каком месте файла это делать, можно и в начале

* Если что-то экспортируется отдельно, оно заключается в { }, будь то переменная или функция

* Все, что не экспортируется, не видно вне файла

  

* Импортировать можно все разом. Для этого указывается `*` и `as псевдоним` (as обязателен).

* Если как в примере, из файла есть одновременный обычный экспорт и default, то экспортированная как default не доступна через псевдоним - в примере info.FullInfo() не воспринимается как функция. То есть дефолтная штука является самостоятельной и не видна в общем * экспорте

* Вещь, экспортированную через export default, можно импортировать под любым псевдонимом. Он пишется сразу и без скобок, как Author в примере

* Все, что экспортировано через обычный export, можно импортировать по исходным именам и при желании дать им другое имя



## Пути, import React from 'react'

При импорте указывается относительный путь

> Как указывать абсолютный, внятного ответа я не нашел.

Три основных вида пути:

```react
[1] import Main from './components/main/Main'
[2] import Ohter from '../other/Other'
[3] import React from 'react'
```

* `./` означает отсчет от текущей директории
* `../` переход в родительскую директорию
* Если не указано ни того, ни другого, это означает искать в `node_modules`

Есть техника, когда вместо файла в импорте указывается папка. В этом случае в ней должен лежать файл `index.js` и вебпак поймет, что надо делать импорт из него:

<img src="img\image-20200515111023849.png" alt="image-20200515111023849" style="zoom:80%;" />

> В строчке `import React from 'react'` кроется какая-то особенность. Не знаю как это работает. Сначала думал, что по технике выше. Но, во-первых, React тут пишется с большой буквы, а папка в node_modules называется react, то есть с маленькой. При таких условиях обычные импорты у меня не работали.

Для лучшей структуризации можно в папке сделать несколько файлов с компонентами, вложить их друг в друга, а в index.js оставить только это (подробнее - в разделе структуризация файлов):

```react
export {default} from './about-page'
```



# Маршрутизация

Нужен пакет `react-router-dom`

Основные компоненты `BrowserRouter`, `NavLink`, `Link `, `Switch`, `Route`

> Дописать про редирект

<p align="center"><b>[1]</b></p>

Оборачиваем приложение в BrowserRouter:

<img src="img\image-20200515131112212.png" alt="image-20200515131112212" style="zoom:80%;" />

<p align="center"><b>[2]</b></p>

В приложении делаем сопоставление маршрутов и компонентов:

<img src="img\image-20200515131253988.png" alt="image-20200515131253988" style="zoom:80%;" />

Уже можно переходить между "страницами", вводя ссылки в браузер. В случае с корнем надо писать exact, иначе все время будет открываться главная страница, даже если попробовать перейти на about. Если в Route не указывать path, это расценивается как "что бы то ни было, введенное в адресную строку".

<p align="center"><b>[3]</b></p>

В компоненте главной страницы я подключил собственный компонент меню:

<img src="img\image-20200515131410864.png" alt="image-20200515131410864" style="zoom:80%;" />

<p align="center"><b>[4]</b></p>

Чтобы реализовать переходы между компонентами с помощью ссылок, пользуемся NavLink или Link.  В них указываются зарегистрированные в Switch маршруты:

<img src="img\image-20200515131515555.png" alt="image-20200515131515555" style="zoom:80%;" />

Единственное отличие NavLink и Link в том, что NavLink имеет дополнительный атрибут стиля для "текущей" ссылки - если текущая страница совпадает с ссылкой, ее для удобства можно раскрасить особенным образом.



# Структуризация файлов

```react
export {default} from './about-page'
```



# Компоненты-функции и хуки





# Форма сохранения на сервер

Привожу полный пример набора компонентов, которые позволяют сохранить введенные в форму данные о сотруднике на сервер. Без Redux.

Для работы нам понадобятся: главный файл (1). В нем мы объявим переменную с сотрудником и функции-обработчики, которые передадим в файл с формой (2) и элементами ввода (3). Таким образом, в (1) мы подготовим всю логику, а (2) и (3) будут просто содержать разметку и принимать готовые  функции, которые им надо будет просто вызвать.

<img src="img\image-20200520183013546.png" alt="image-20200520183013546" style="zoom:80%;" />

**[1-6]** Переменную для хранения объекта сотрудника и сеттер для него создаем с помощью хука. Изначально объект абсолютно пустой и не содержит ни одного поля. Однако нам очевидно известна структура этого объекта и как должны называться его поля.

**[1-8]** `handleChange` - это функция обработки изменения значения в полях ввода. Когда пользователь вводит что-то в поле, мы хотим получать это значение и сохранять в объект сотрудника. Она проходит нелегкий путь, прежде чем попасть в фактическое место вызова. Ее удалось сделать общей для всех полей за счет некоторых особенностей:

В компоненте формы **[2]** мы объявляем форму и внутри нее добавляем несколько компонентов `Input` - удобных оберток для "настоящих" input'ов. В каждую обертку мы передаем кроме всего прочего имя, причем эти имена [2-10], [2-15], [2-20], [2-25] совпадают с полями объекта сотрудника не просто так.

**[3-11]** У компонента `input`, в который фактически вводятся данные, есть событие `onChange`. Оно возникает каждый раз, когда текст в поле меняется, причем сразу, то есть при вводе каждого символа. В качестве обработчика мы как раз устанавливаем прокинутую из главного компонента функцию `handleChange` и она получает через параметр объект события - `event` [1-8]. У него есть поле `target` - непосредственно элемент, в котором произошло событие, а у него, в свою очередь, два полезных для нас свойства - `name` и `value`. То есть имя элемента и введенное в него значение.

Имена, соответственно, приходят сюда такие, какие мы задаем в [2-10], [2-15], [2-20], [2-25]. Этот код

```react
const handleChange = (event) => {
  const {name, value} = event.target
  setEmp(empPrevValue => ({
    ...empPrevValue, [name]: value
  }))
}
```

занимается формированием объекта. Поскольку изначально объект пустой, нам нужно не только заполнить его поля значениями, но и, вообще-то говоря, создать в нем эти поля.

В JS можно создавать поля для объекта, просто указывая их имена в квадратных скобках `person["firstName"] = "Вася"`. Именно благодаря этому из [name] получается фактическое имя поля (например, titleOfCourtesy) и обновленное значение этого поля за счет "спреда" заменяет старое значение в новом объекте. Ну а потом новый объект перезаписывает старый.

Я удалил тут лишние объяснения, потому что они, по-моему, понятнее не делали. Это такие вещи, которые проще понять, просто всматриваясь в этот кусок кода, нежели как-то описать. Надо понимать как оператор ... (spread) работает. А вот зачем тут дополнительные () после => этого я даже сейчас пока не понимаю)

С сохранением такая же ситуация - пробрасываем функцию `handleSave` в компонент с формой, а он ее просто вызывает. Объект сотрудника передаем, чтобы проверить, есть ли в нем Id. Когда сотрудник еще не сохранен, у него нет Id и поле для отображения Id скрыто. После сохранения Id появляется и поле становится видимым. А в функции сохранения Id позволяет решить, какой тип запроса нужно отправлять - на создание ресурса или на обновление.

Обработка ответа тут показана самая простая. А вообще там есть тоже статус, который можно проверять, но это отдельная тема.

<p align="center">[1]</p>

<img src="img\image-20200520164724303.png" alt="image-20200520164724303" style="zoom:80%;" />

<img src="G:\Documents\typora\NextLevel\React-Redux\React - Основы\img\image-20200520164739906.png" alt="image-20200520164739906" style="zoom:80%;" />

<img src="G:\Documents\typora\NextLevel\React-Redux\React - Основы\img\image-20200520164804323.png" alt="image-20200520164804323" style="zoom:80%;" />

<p align="center">[2]</p>

<img src="img\image-20200520164917525.png" alt="image-20200520164917525" style="zoom:80%;" />

<img src="img\image-20200520164944994.png" alt="image-20200520164944994" style="zoom:80%;" />

<p align="center">[3]</p>

<img src="img\image-20200520165052313.png" alt="image-20200520165052313" style="zoom:80%;" />



