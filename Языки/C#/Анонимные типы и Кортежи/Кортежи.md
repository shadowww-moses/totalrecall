Кортежи немного похожи на анонимные типы в том плане, что позволяют на лету создавать объекты. Они были созданы для упрощения возврата из методов сразу нескольких значений.

Кортежи представлены в виде двух дженерик-типов:

* Tuple
* ValueTuple

Отличие в том, что первый - это reference type построен на объектах, а второй - value type построен на структурах. Хотя у Албахари написано, что "оглядываясь назад, можно сказать, что определение кортежей как классов было заблуждением" и "при добавлении в C# 7 языковой поддержки для кортежей существующие типы Tuple были проигнорированы в пользу новых типов ValueTuple", мне встретилась интересная задача, которую можно решить как с Tuple, так и с ValueTuple. Она будет в конце заметки.



# Создание кортежей

► Кортеж может содержать любое количество полей. Вот все варианты синтаксиса создания и доступа к полям:

```c#
var user = ("Sam", 35);
var user = (Name: "Sam", 35);
var user = (Name: "Sam", Age: 35);
Console.WriteLine(user.Item1);
Console.WriteLine(user.Name);

(string, int, int) user = ("Sam", 35, 15);
(string, int, int) user = ("Sam", Age: 35, 15);
(string Name, int Age, int Exp) user = ("Sam", 35, 15);

string name = "Sam";
int age = 35;
var user = (name, age);
Console.WriteLine(user.Item1);  // Sam
Console.WriteLine(user.name);  // Sam
```

К полям можно получить доступ через свойства Item1, Item2 и так далее. Этих свойств будет столько же, сколько и полей. Можно дать полю имя, при этом все равно остается возможность обратиться к нему через ItemN. Давать\не давать имена можно вперемешку. Имя можно указать либо в самом объекте, либо при указании типов полей. Если поля формируются из переменных, то имена для них могут быть выведены автоматически. В общем, все в примерах есть.

► Поля в кортежах можно изменять (в отличие от анонимных типов). Плюс поскольку кортежи - это value type, их легко копировать:

```c#
(string Name, int Age) user = ("Sam", 35);
var admin = user;  // копируем

admin.Name = "Frodo";  // изменяем
Console.WriteLine(user.Name);  // Sam - "оригинал" не тронут
Console.WriteLine(admin.Name);  // Frodo
```

Для копирования необходимо, чтобы типы параллельных полей у кортежей совпадали. При этом имена значения не имеют, поэтому может случиться казус:

```c#
(string Name, int Age) user = ("Sam", 35);
(string Address, int Weight) package = user;

Console.WriteLine(package.Address);  // Sam
```

Мы скопировали пользователя в посылку.

► Кортежи легко возвращать из методов и использовать совместно с дженериками:

```c#
Func<string, int, (string Name, int Age)> createUser = 
    (string name, int age) => (name, age);

var user = createUser("Sam", 35);
Console.WriteLine($"{user.Name}, {user.Age}");
```



# Деконструирование

Кортежи можно раздербанить на свойства, поместив их соответственно порядку в переменные:

```c#
var user = (NameField: "Sam", AgeField: 35);

(string name, int age) = user;  // Деконструирование
Console.WriteLine(name);  // Sam
Console.WriteLine(age);  // 35

Console.WriteLine(user.NameField);  // Sam
```

При этом сам кортеж остается как был, а не уничтожается, как можно было бы подумать из названия "деконструирование"



# Сравнение

Для кортежей нормально работает оператор ==, а не только Equals:

```c#
(string Name, int Age) user = ("Sam", 35);
(string Name, int Age) admin = ("Sam", 35);
(string Name, int Age) owner = ("Frodo", 35);

Console.WriteLine(user == admin);  // True
Console.WriteLine(admin == owner);  // False

Console.WriteLine(user.Equals(admin));  // True
Console.WriteLine(admin.Equals(owner));  // False
```



# Дополнительно

► С кортежами не работает рефлексия

► Если положить кортеж и анонимный объект в переменную типа object:

```c#
var userAnonType = new { name = "Sam", age = 35 };
var userValTuple = ( name: "Same", age: 35 );

object user1 = userValTuple;
object user2 = userValTuple;
```

то в отладчике поля анонимного объекта будут под именами name и age, а поля кортежа - Item1 и Item2. Это происходит потому, что для анонимных объектов компилятор создает типы с именованными полями, а в случае с кортежами просто использует структуры ValueTuple<T1, T2, ... TN>, и поэтому имена после компиляции пропадают.



# Пример

Выше были простые демонстрации синтаксиса. А вот реальная задача, в которой кортежи Tuple были использованы оригинальным способом.

> Напишите функцию, которая принимает строку и возвращает символ, который образует наибольшую непрерывную последовательность, а также длину этой последовательности. Для пустой строки верните null вместо символа и 0 для количества
>
> Например: 
>
> "aaabbcccc" > c, 4
>
> "" > null, 0

Вот решение через Tuple:

```c#
public static Tuple<char?, int> LongestRepetition(string input)
{
    return input.Select(
        	(ch, ind) => new Tuple<char?, int>(
	            	ch,
	            	input.Substring(ind).TakeWhile(t => t == ch).Count()
            	)
    	)
        .OrderByDescending(t => t.Item2)
        .FirstOrDefault()
        ?? new Tuple<char?, int>(null, 0);
}
```

А вот через ValueTuple:

```c#
public static (char?, int) LongestRepetition(string input)
{
    return input
        .Select((ch, ind) => 
                new ValueTuple<char?, int>(
                    ch, 
                    input.Substring(ind).TakeWhile(t => t == ch).Count()
                )
        )
        .OrderByDescending(t => t.Item2)
        .FirstOrDefault();
}
```

Мы обходим с помощью Select каждый символ в строке. Синтаксис Select для локальных коллекций позволяет получить не только сам элемент, но и его индекс в коллекции. Этим мы и пользуемся, получая очередной символ и его позицию в строке (ch, ind). Используя этот индекс, мы выделяем подстроку от этого символа и до конца строки, и с помощью TakeWhile начинаем выбирать непрерывную последовательность одинаковых символов в ней. Потом через Count() получаем ее длину. 

Таким образом, каждый символ мы преобразуем в Tuple, где первый элемент - символ, а второй - его непрерывная длина. Сортируем по убыванию длины и выбираем первый элемент.

И вот тут важный момент, отличающий решение с Tuple от ValueTuple. Если строка пустая, то по условию нас просят вернуть <null, 0>. Если использовать `ValueTuple<char?, int>`, то FirstOrDefault() сразу возвращает нам структуру, в которой лежат значения <null, 0>, потому что дефолтное значение для этого типа как раз и есть структура.

Если же использовать `Tuple<char?, int>` тогда FirstOrDefault() вернет null, потому что Tuple это класс и для него дефолтным является null. И тогда нам придется этот null анализировать через ?? и самостоятельно создавать новый кортеж из значений <null, 0>. Таким образом, через ValueTuple решение чуть лаконичнее. Однако тест для пустой строки у меня не сработал, потому что (null, 0) не смог к object привестись почему-то. Но результат все равно правильный, просто тест не проходит.