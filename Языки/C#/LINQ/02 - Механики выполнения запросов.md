# Механики выполнения запросов

Несмотря на ранее сказанное, что операция возвращает последовательность, в переменных из примеров выше еще нет никаких данных, а только запросы, которые позволяют их получить. Это связанно с механикой отложенного выполнения.

## Отложенное выполнение

```c#
var nums = new List<int>(5) { 3, 2, 4, 1 };

// Запрос описан, но еще не выполнен
var odds = nums.Where(n => n%2 != 0).OrderBy(n => n); 
nums.Add(5);

// Выполнение начинается здесь, поэтому 5 участвует в сравнении
foreach (var num in odds)
{
    Console.WriteLine(num);  // 1, 3, 5
}
```

В odds мы поместили запрос. Это еще не набор данных, а только ряд инструкций, сообщающий, какие действия нужно применить к исходной последовательности (nums), чтобы получить результат. Таким образом, запрос выполняется не когда он написан, а когда мы обращаемся к нему, пытаясь получить данные. Это называется _**отложенным**_ или _**ленивым**_ (lazy) выполнением.

При этом, раз odds - это только инструкция как из исходной последовательности получить результирующую, то если нам понадобится еще раз получить данные, то вся цепочка операций должна выполниться с самого начала. Если она длинная и содержит сложную логику, то это может занимать много времени.

В итоге мы получаем одновременно как плюс (в примере не теряем элемент, добавленный в исходную последовательность уже после написания запроса), так и минус от отложенного выполнения. Впрочем, от минуса легко избавиться - для этого нужно в конец запроса добавить команду сохранения результата в массив или список с помощью [методов **.ToArray()** или **.ToList()**](#.ToArray,-ToList,-.ToDictionary,-.ToLookup). Это приведет к немедленному выполнению запроса и результат сохранится в переменную. Тогда поведение примера поменяется следующим образом:

```c#
var nums = new List<int>(5) { 3, 2, 4, 1 };

// Теперь odds уже не просто инструкция, а непосредственно сами данные
var odds = nums.Where(n => n%2 != 0).OrderBy(n => n).ToList();
nums.Add(5);  // Поэтому 5 не участвует в запросе

foreach (var num in odds)
{
    Console.WriteLine(num);  // 1, 3
}
```

## Захват переменных в запросах

С отложенным выполнением связан еще один важный момент. Но перед его рассмотрением познакомимся с построением запроса "в несколько шагов". До этого мы применяли последовательно несколько запросов, выстраивая из них цепочку в явном виде (nums.Where(...).OrderBy(...)), поэтому следующий способ может показаться неочевидным. Вот программа, которая должна удалять из строки все гласные буквы:

```c#
IEnumerable<char> phrase = "You expect string with no vowels";
string vowels = "aeiou";

// Здесь запрос формируется
for (int i = 0; i < vowels.Length; i++)
{
   phrase = phrase.Where(l => l != vowels[i]);
}

// Здесь запрос выполняется, когда мы начинаем обращаться к данным
foreach (var c in phrase)
{
   Console.Write(c);
}
```

Каждый шаг цикла "заворачивает" предыдущую цепочку в новый запрос. В итоге после цикла получается запрос, по виду напоминающий такую конструкцию:

```c#
phrase = phrase
    .Where(l => l != vowels[i])
    .Where(l => l != vowels[i])
    .Where(l => l != vowels[i])
    .Where(l => l != vowels[i])
    .Where(l => l != vowels[i])
```

А вот что будет вместо i, сейчас разберемся. Начнем с того, что программа не работает, она выдает исключение System.IndexOutOfRangeException: "Индекс находится вне границ массива." Почему? Потому что значения переменных, используемых в запросе, берутся те, которые есть на момент выполнения, а не на момент написания запроса. Следовательно, i в момент выполнения имеет значение 5 и запрос выглядит так:

```c#
phrase = phrase
    .Where(l => l != vowels[5])
    .Where(l => l != vowels[5])
    .Where(l => l != vowels[5])
    .Where(l => l != vowels[5])
    .Where(l => l != vowels[5])
```

вместо ожидаемого

```c#
phrase = phrase
    .Where(l => l != vowels[0])
    .Where(l => l != vowels[1])
    .Where(l => l != vowels[2])
    .Where(l => l != vowels[3])
    .Where(l => l != vowels[4])
```

Чтобы программа заработала, нужно изменить способ передачи буквы в запрос:

```c#
IEnumerable<char> phrase = "You expect string with no vowels";
string vowels = "aeiou";

for (int i = 0; i < vowels.Length; i++)
{
   char vowel = vowels[i];
   phrase = phrase.Where(l => l != vowel);
}
```

Теперь переменная vowel создается заново в каждом шаге цикла и уничтожается в конце шага. Но из-за механизма работы замыканий (Албахари, C# 7.0, стр.177) ее значение сохраняется в лямбда-выражении, используемом в запросе, и запрос получает свой правильный вид:

```c#
phrase = phrase
    .Where(l => l != 'a')
    .Where(l => l != 'e')
    .Where(l => l != 'i')
    .Where(l => l != 'o')
    .Where(l => l != 'u')
```

А вот еще способ написать этот цикл:

```c#
IEnumerable<char> phrase = "You expect string with no vowels";
string vowels = "aeiou";

foreach (var vowel in vowels)
{
    phrase = phrase.Where(l => l != vovel);
}
```

Через регулярные выражения:

```c#
string phrase = "String with no vowels";
var r = string.Join(" ", phrase.Split().Select(s => Regex.Replace(s, "[aeoui]", "")));
```

## Локальные и интерпретируемые запросы

Самое важное практическое отличие в том, что интерпретируемые запросы ограничены функционалом СУБД, в синтаксис которой они транслируются. Например, есть EF-таблица со списком людей и нужно выбрать всех, у кого имя соответствует некоторому шаблону. Просто написать через регулярное выражение не получится, потому что СУБД не знает регулярных выражений. По этой же причине нельзя внутри запроса к такой таблице использовать какие-то свои методы преобразования - потому что все это не сможет транслироваться в SQL-запрос.

Такие задачи решаются в два шага - сначала пишется запрос, который может полностью транслироваться в SQL, а затем к нему применяется метод _**AsEnumerable()**_ и остаток вычислений уже производится локально. Кроме того, можно использовать методы ToArray или ToList для получения локальной последовательности, но AsEnumerable() может быть предпочтительнее из-за того, что он не приводит к немедленному вычислению результата

```c#
IEnumerable<guest> guests = _hotel.guest.AsEnumerable()
    .Where(g => Regex.IsMatch(g.name, pattern);

guests = ApplyBirthFilter(guests, birth);
```
