# Сборка мусора и освобождение

Управление памятью в .NET осуществляется автоматически CLR. Сюда входит выделение памяти и ее очищение от неиспользуемых объектов. Непосредственно этими вещами занимается сборщик мусора, являющийся частью CLR. Он периодически активируется и определяет объекты, подлежащие удалению.

При запуске программы ей выделяется непрерывная область памяти, называемая *управляемой кучей*. В ней и размещаются объекты. В зависимости от времени нахождения в памяти, объекты делятся на *поколения*. Принцип деления таков: только что размещенные объекты относятся к поколению 0. Объекты, пережившие одну сборку мусора, становятся поколением 1. Еще более старшие объекты - поколение 2. На рисунке показано, как объекты перемещаются из поколения в поколение:

![1575269811250](img\1575269811250.png)

Размер области памяти под Gen0 и Gen1 небольшой и при сборке мусора объекты этих поколений проверяются в первую очередь. Это происходит быстро. Объекты Gen2 проверяются относительно редко и полная сборка мусора занимает довольно много времени, поэтому выполняется значительно реже.

После сборки мусора куча *сжимается* - все активные объекты смещаются в ее начало. Это упрощает выделение памяти под новые объекты - она всегда выделяется в конце кучи. Однако может возникнуть ситуация, когда даже после сборки мусора памяти для нового объекта не хватает. Тогда генерируется исключение *OutOfMemoryException*.

Объект становится пригодным для удаления, когда на него прямо или косвенно не ссылается *корневой объект* (*корень*) - например, локальные и статические переменные, параметр метода, объект очереди финализации. Циклическая ссылка, как показано на рисунке, не считается - корни не имеют связи с красным объектом, а значит он и вся остальная группа подлежат удалению.

![1575264648855](img\1574759804880.png)

# Финализаторы

Некоторые объекты имеют *финализатор* - специальный метод, который выполняется в промежутке между тем, как сборщик мусора сочтет объект пригодным для удаления, и непосредственным удалением объекта из памяти.

> Финализатор и деструктор - не одно и то же. Главное отличие в том, что деструктор выполняется в предсказуемое время - в момент выхода объекта из области видимости или в момент вызова оператора удаления объекта. А  момент выполнения финализатора нам до конца неизвестен. В C# нет деструкторов, таких как в C++.

Такие объекты удаляются особым образом: когда такой объект становится пригодным для удаления, сборщик мусора помещает его в специальную очередь - *очередь финализации*. Затем в момент начала сборки мусора запускается параллельный основной программе *поток финализаторов*, который выполняет финализаторы этих объектов. Когда финализаторы выполнены, объекты удаляются из очереди финализации и остаются висеть в памяти в недоступном состоянии до следующей сборки мусора. И когда она наступает, они окончательно удаляются.

