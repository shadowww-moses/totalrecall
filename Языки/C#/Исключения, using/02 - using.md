Некоторые объекты в .NET требуют явного освобождения памяти. Например, файлы. Такие объекты реализуют интерфейс IDisposable, у них есть метод Dispose(), который надо явно вызвать по окончанию работы с объектом, чтобы память корректно освободилась.

Оператор using упрощает работу с такими объектами:

```c#
using (var fs = new FileStream("myFile.txt", FileMode.Open))
{
    ...
}
```

Упрощение заключается в том, что при компиляции этот оператор разворачивается в такую конструкцию:

```c#
FileStream fileStream = new FileStream("myFile.txt", FileMode.Open);
try
{
    ...
}
finally
{
	if (fileStream != null)
    {
        ((IDisposable)fileStream).Dispose();
    }
}
```

То есть программисту не приходится писать код вызова Dispose() руками.

В обоих примерах не проверяется существование файла. Поэтому, если его нет, возникнет исключение, которое нужно обрабатывать отдельно:

```c#
try
{
    using (var fs = new FileStream(@"C:\tmp\text.txt", FileMode.Open))
    {
		...
    }
}
catch (FileNotFoundException e)
{
    Console.WriteLine("File not found");
}
```

Или

```c#
try
{
    using (var fs = new FileStream(@"C:\tmp\text.txt", FileMode.Open))
    {

    }
}
catch (SqlException e) 
{ 
}
finally
{
    Console.WriteLine("File not found.");
}
```

Файл не существует, а блок catch не среагирует на это, потому что ловит совершенно другой тип исключения. Поэтому finally не выполнится. Чтобы этого избежать, можно добавить отлов общего типа `catch (Exception ex)`

То есть using только гарантирует вызов Dispose() на успешно созданном объекте и при работе с которым не возникло проблем, а вот проверкой возможности создания этого объекта или контролем, все ли идет нормально в процессе работы, он не занимается. Это нужно делать самостоятельно.

> Еще хочу отметить такой момент: поскольку using разворачивается в try-finally и catch в нем отсутствует, то в случае ошибки в try, finally не выполнится и ресурс не освободится. Например, файл создался успешно, но при чтении возникла какая-то ошибка. Внешний catch ее конечно поймает, но вот за счет того, что внутренний finally не выполнится, ресурс останется неосвобожденным.
>
> UPD. Специально оставил предыдущее замечание, чтобы явно опровергнуть его. Внутренний finally выполнится, если исключение в принципе поймано - не важно где, даже если во внешнем try-catch. Пример:
>
> ```c#
> try
> {
>     try
>     {
>         throw new ArgumentNullException();
>     }
>     finally
>     {
>         Console.WriteLine("inner finally");
>     }
> }
> catch
> {
>     Console.WriteLine("outter catch");
> }
> finally
> {
>     Console.WriteLine("outter finally");
> }
> ```
>
> Выведется inner finaly - outter catch - outter finally. То есть, несмотря на то, что во внутреннем блоке try отсутствует catch, его finally все равно выполнится, потому что исключение отлавливается внешним catch (причем выполнится этот внутренний finally ДО этого catch).



# Итого

using упрощает вызов Dispose, однако отловом исключений не занимается. Поэтому если возникнет ошибка в процессе работы, Dispose не вызовется. Так что сам using тоже надо оборачивать в try