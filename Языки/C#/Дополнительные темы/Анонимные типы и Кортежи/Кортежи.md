Кортежи - это value type

Кортежи немного похожи на анонимные типы в том плане, что позволяют на лету создавать объекты. Они были созданы для упрощения возврата из методов сразу нескольких значений.

В основе кортежей лежит тип `ValueTuple<...>` Он включен в стандартную библиотеку, начиная с .NET Framework 4.7, а при использовании в более ранних версиях нужно установить пакет System.ValueTuple через NuGet

# Создание кортежей

► Кортеж может содержать любое количество полей. Вот все варианты синтаксиса создания и доступа к полям:

```c#
var user = ("Sam", 35);
var user = (Name: "Sam", 35);
var user = (Name: "Sam", Age: 35);
Console.WriteLine(user.Item1);
Console.WriteLine(user.Name);

(string, int, int) user = ("Sam", 35, 15);
(string, int, int) user = ("Sam", Age: 35, 15);
(string Name, int Age, int Exp) user = ("Sam", 35, 15);

string name = "Sam";
int age = 35;
var user = (name, age);
Console.WriteLine(user.Item1);  // Sam
Console.WriteLine(user.name);  // Sam
```

К полям можно получить доступ через свойства Item1, Item2 и так далее. Этих свойств будет столько же, сколько и полей. Можно дать полю имя, при этом все равно остается возможность обратиться к нему через ItemN. Давать\не давать имена можно вперемешку. Имя можно указать либо в самом объекте, либо при указании типов полей. Если поля формируются из переменных, то имена для них могут быть выведены автоматически. В общем, все в примерах есть.

► Поля в кортежах можно изменять (в отличие от анонимных типов). Плюс поскольку кортежи - это value type, их легко копировать:

```c#
(string Name, int Age) user = ("Sam", 35);
var admin = user;  // копируем

admin.Name = "Frodo";  // изменяем
Console.WriteLine(user.Name);  // Sam - "оригинал" не тронут
Console.WriteLine(admin.Name);  // Frodo
```

Для копирования необходимо, чтобы типы параллельных полей у кортежей совпадали. При этом имена значения не имеют, поэтому может случиться казус:

```c#
(string Name, int Age) user = ("Sam", 35);
(string Address, int Weight) package = user;

Console.WriteLine(package.Address);  // Sam
```

Мы скопировали пользователя в посылку.

► Кортежи легко возвращать из методов и использовать совместно с дженериками:

```c#
Func<string, int, (string Name, int Age)> createUser = 
    (string name, int age) => (name, age);

var user = createUser("Sam", 35);
Console.WriteLine($"{user.Name}, {user.Age}");
```



# Деконструирование

Кортежи можно раздербанить на свойства, поместив их соответственно порядку в переменные:

```c#
var user = (NameField: "Sam", AgeField: 35);

(string name, int age) = user;  // Деконструирование
Console.WriteLine(name);  // Sam
Console.WriteLine(age);  // 35

Console.WriteLine(user.NameField);  // Sam
```

При этом сам кортеж остается как был, а не уничтожается, как можно было бы подумать из названия "деконструирование"



# Сравнение

Для кортежей нормально работает оператор ==, а не только Equals:

```c#
(string Name, int Age) user = ("Sam", 35);
(string Name, int Age) admin = ("Sam", 35);
(string Name, int Age) owner = ("Frodo", 35);

Console.WriteLine(user == admin);  // True
Console.WriteLine(admin == owner);  // False

Console.WriteLine(user.Equals(admin));  // True
Console.WriteLine(admin.Equals(owner));  // False
```



# Дополнительно

► С кортежами не работает рефлексия

► Если положить кортеж и анонимный объект в переменную типа object:

```c#
var userAnonType = new { name = "Sam", age = 35 };
var userValTuple = ( name: "Same", age: 35 );

object user1 = userValTuple;
object user2 = userValTuple;
```

то в отладчике поля анонимного объекта будут под именами name и age, а поля кортежа - Item1 и Item2. Это происходит потому, что для анонимных объектов компилятор создает типы с именованными полями, а в случае с кортежами просто использует структуры ValueTuple<T1, T2, ... TN>, и поэтому имена после компиляции пропадают.