Я долго думал, стоит ли вообще пытаться что-то писать о лямбдах, потому здесь очень сильно ощутил принцип "Easy to learn, hard to master", только сказать можно "Easy to understand, hard to explain". Использовать их - проще простого. Пытаться описать словами - нереально сложно. И не очень понятно, стоит ли это пытаться делать, поскольку пишу я для себя, а я их уже понимаю. Понимаю, имеется ввиду, на уровне пользования. А как все это работает совсем-совсем внутри, во-первых, найти трудно и, во-вторых, не особо полезно на практике. Знаешь и знаешь, не знаешь - по сути ничего не меняется. Поэтому я решил здесь переломить желание "разобраться до косточек" и просто описать с практической точки зрения кое-какие вещи.



Все же сделаю небольшое теоретическое вступление. Отсебятина и домысливание, пусть будет, а если когда-нибудь пойму, что где-то тут ошибки, будет интересно.

Такое определение лямбдам дают братья Албахари:

> Лямбда-выражение - это неименованный метод, записанный вместо экземпляра делегата

Что бы ни значило это "записанный вместо", по сути - лямбда это просто значение, как например, цифра 5 или строка"Hello, world!", только ее значение это не пятерка или hello world, а метод. И поскольку лямбда - значение, ее нужно либо положить в переменную, либо передать как параметр - нельзя просто подвесить ее в воздухе, иначе будет ошибка "Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement".

И также как пятерка или строка преобразуется в какой-то внутренний тип платформы, так же и лямбду компилятор преобразует или в экземпляр делегата, или в дерево выражений. Я не знаю сейчас, что такое дерево выражений.



# Анонимные методы и лямбды

Анонимные методы появились в C# 2.0, а лямбды - в C# 3.0

По сути они, видимо, почти одно и то же, только лямбды более удобные синтаксически.

## Синтаксис

Анонимные методы:

```c#
Func<string, string> greet = delegate (string username)
{
    var message = "Hello, " + username;
    return message;
};
```

Лямбды:

```c#
Func<string, string> greet = (username) =>
{
    var message = "Hello, " + username;
    return message;
}
```



## Отличия

Вот что написано у Албахари про анонимные методы:

► Анонимный метод похож на лямбда-выражение, но:

* У анонимных методов нет неявно типизированных параметров

  По сути это означает, что где лямбду можно записать вот так:

  ```c#
  Action<string> greet = (username) => Console.WriteLine($"Hello, {username}!");
  greet("Tommy");
  ```

  то анонимный метод придется вот так, с обязательным указанием типа параметра username:

  ```c#
  Action<string> greet = delegate (string username) 
  { 
      Console.WriteLine($"Hello, {username}!"); 
  };
  greet("Tommy");
  ```

* У анонимных методов отсутствует синтаксис выражений, т.е. их тело всегда является блоком операторов, заключенных в фигурные скобки, даже если там всего одна строчка:

  ```c#
  Func<string, string> greet = delegate (string username)
  {
      return $"Hello, {username}!";
  };
  Console.WriteLine(greet("Tommy"));
  ```

  против вот такой краткости у лямбд:

  ```c#
  Func<string, string> greet = (username) => $"Hello, {username}!";
  Console.WriteLine(greet("Tommy"));
  ```

* Анонимные типы не компилируются в дерево выражения при присвоении объекту типа `Expression<T>`

  Я не знаю, что такое дерево выражения, поэтому не могу прокомментировать этот пункт

► Зато у анонимных методов есть преимущество - даже если делегат требует параметры, то можно в его экземпляр положить анонимный метод, у которого параметров нет:

```c#
Action<string, string> greet = delegate { };  // Ok
```

С лямбдами такое не сработает:

```c#
Action greet = () => { };  // Ok
Action<string, string> greet = () => { };  // Error
```

Ошибка: "Delegate 'Action<string, string>' does not take 0 arguments"

Эту особенность можно использовать, например, чтобы не проверять на null содержимое делегата события, а просто вызывать его, не боясь ошибки в случае отсутствия подписчиков:

```c#
public event Action<string, string> greet = delegate { };
greet("Hello", "world");
```

Хотя пример уже притянут за уши, потому что существует оператор `?.` и стандартный шаблон описания событий

## Вывод

Анонимные методы получается вроде бы и не нужны
