# Замыкания

Замыкания работают одинаково с анонимными методами и лямбдами. Здесь я попытался написать попроще, но приложил еще пару интересных статей.

## Интро

Рассмотрим несколько примеров и понаблюдаем за результатами:

Первый:

```c#
Action print = delegate { };

for (var i = 0; i < 3; i++)
{
    print += () => Console.Write(i);
}

print();  // 333
```

Второй:

```c#
Action print = delegate { };

for (var i = 0; i < 3; i++)
{
    var fix = i;
    print += () => Console.Write(fix);
}

print();  // 012
```

Переменные `i` и `fix` по отношению к лямбде называются *свободными* - то есть не объявлены внутри нее и не являются ее параметрами.

Третий:

```c#
Action print = delegate { };

foreach (var i in Enumerable.Range(0, 3))
{
    print += () => Console.WriteLine(i);
}

print();  // 012
```



## Как реализуются замыкания внутри

► Во всех случаях для работы с замыканием компилятор создает вспомогательный класс. Свободные переменные и функцию, которая формирует замыкание, он добавляет в этот класс в качестве полей и метода. Потом он создает объект этого класса и кладет в поля значения, а в место, где была функция, подставляется метод объекта. 

► Из первого примера получается примерно следующее (на первый раз я стер "шумовые" вещи вроде пространства имен и др., мешающее восприятию):

```c#
Action print = new Action(c.9.<Main>b__0_0));
c__DisplayClass0_0 c__DisplayClass0_ = new c__DisplayClass0_0();
c__DisplayClass0_.i = 0;
while (c__DisplayClass0_.i < 3)
{
    print = (Action)Delegate.Combine(print, new Action(c__DisplayClass0_.<Main>b__1));
    c__DisplayClass0_.i++;
}
print();
```

Если присмотреться, по сути получается нечто такое:

```c#
private sealed class DisplayClass  // <-- компилятор сделал это автоматически
{
    public int i;
    public void Method() 
    {
        Console.WriteLine(i);
    }
}

Action print = delegate { };

DisplayClass display = new DisplayClass();  // <-- компилятор создал объект
while (display.i < 3;)  // <-- вместо переменной теперь тут поле объекта
{
    print += new Action(display.Method);  // <-- вместо лямбды теперь тут метод объекта
    display.i++;
}

print();  // 333
```

Примерно в такой код преобразуется наш исходный код. Теперь за счет того, что в экземпляре делегата, print, используется ссылка на объект display, этот объект будет лежать в памяти до тех пор, пока существует экземпляр делегата.

Важным тут является то, что объект типа DisplayClass тут один и поле у него после завершения цикла равняется 3. И каждый делегат в цепочке print ссылается на метод одного и того же объекта. Так и получается, что при вызове выходит три тройки.

► Во втором случае компилятор генерирует вот такой код:

```c#
System.Action print = ConsoleApp1.Program.<>c.<>9__0_0 ?? (ConsoleApp1.Program.<>c.<>9__0_0 = new System.Action(ConsoleApp1.Program.<>c.<>9.<Main>b__0_0));
	int i = 0;
	while (i < 3)
	{
		ConsoleApp1.Program.<>c__DisplayClass0_0 <>c__DisplayClass0_ = new ConsoleApp1.Program.<>c__DisplayClass0_0();
		<>c__DisplayClass0_.fix = i;
		print = (System.Action)System.Delegate.Combine(print, new System.Action(<>c__DisplayClass0_.<Main>b__1));
		i++;
	}
	print();
```

Если присмотреться, то видно, что, в отличие от первого примера, здесь каждый шаг цикла создается *новый* объект. Соответственно, делегаты в цепочке print ссылаются на разные объекты и поэтому выводится 012.

В третьем случае суть такая же как и во втором - каждый шаг цикла создается новый объект.

## Выводы

Замыкания в C# работают за счет вспомогательных объектов, создаваемых компилятором автоматически. На основе лямбд или анонимных методов в этих объектах создаются методы, а свободные переменные становятся полями этих объектов. В исходном коде на месте лямбды (или, опять же, анонимного метода), использующей свободные переменные, создается новый экземпляр делегата, в который помещается метод вспомогательного объекта. За счет этого экземпляра делегата образуется дополнительная ссылка на вспомогательный объект, так что если этот делегат, например, вернуть из функции, то эта ссылка будет удерживать вспомогательный объект в памяти до тех пор, пока существует сама, и функция, лежащая в делегате, будет иметь доступ к переменной.

P.S. Это можно понять только если уже понимаешь. Это скорее не для понимания, а для напоминания. Понять надо на примерах, а это так, канцелярщина и формализм.