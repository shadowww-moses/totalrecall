# Составление шаблона

В шаблонах нужно использовать *дословные строки* `@"Use verbatim string  only"`, потому что это позволяет удобнее экранировать спецсимволы. К  спецсимволам относятся:

```
\  *  +  ?  |  {  [  ()  ^  $  .  #
```

Таким образом, если какой-то из этих символов нужно использовать в  буквальном смысле, его нужно предварить обратным слэшем. Например, нужно найти элемент `for?`:

```c#
string html = "What are you looking for?";
var matches = Regex.Matches(html, @"for\?");
```

Однако, если спецсимвол идет внутри набора символов [], то экранирование не требуется.



# Наборы символов

| Выражение     | Описание                                                     | Инверсия      |
| ------------- | ------------------------------------------------------------ | ------------- |
| [abcdef]      | Соответствие одиночному символу из списка                    | [^abcdef]     |
| [a-f]         | Соответствие одиночному символу в диапазоне                  | [^a-f]        |
| \d            | Соответствие десятичной цифре. Аналогично [0-9]              | \D            |
| \w            | Соответствие любому символу, допустимому в словах. По умолчанию зависит от настройки CultureInfo.CurrentCulture. Для английского языка будет равно [a-zA-Z_0-9], то есть включает не только непосредственно буквы, но еще цифры и символ подчеркивания | \W            |
| \s            | Соответствие любому пробельному символу.<br />Аналогично [\n\r\t\f\v]<br />\n - новая строка<br />\t - табуляция<br />\r - вернуть курсор в начало<br />\f - перевод страницы и \v - вертикальная табуляция, сколько строк пропустить при выводе данных - актуальны только для печати на принтере | \S            |
| \p{категория} | Список категорий:<br />**L** - буквы, **Lu** - большие буквы, **Ll** - маленькие буквы<br />**N** - числа<br />**P** - знаки пунктуации<br />**С** - управляющие символы<br />**Z** - разделители<br />**M** - диактирические знаки (č, ř, ž, в русском, например, ё, й)<br />**S** - символы | \P{категория} |
| **.**         | Любой символ, кроме \n. В режиме единой строки (RegexOptions.SingleLine) вообще любой символ | \n            |



# Квантификаторы

Квантификаторы позволяют указать, сколько раз должен встречаться элемент:

| Квантификатор | Количество совпадений  |
| ------------- | ---------------------- |
| *             | \>=0                   |
| +             | \>=1                   |
| ?             | 0, 1                   |
| {n}           | =n                     |
| {n,}          | \>=n                   |
| {n,m}         | От n до m включительно |

Квантификаторы бывают двух видов: **жадные** и **ленивые**, причем жадные - это режим по умолчанию. Разницу легко понять на примере. Исходная строка:

```c#
string html = "<i>By default</i> quantifiers are <i>greedy</i> creatures";
```

* Жадные

  ```c#
  var matches = Regex.Matches(html, @"<i>.*</i>");
  // <i>By default</i> quantifiers are <i>greedy</i>
  ```

* Ленивые

  ```c#
  var matches = Regex.Matches(html, @"<i>.*?</i>");
  // <i>By default</i>
  // <i>greedy</i>
  ```

Жадный выбрал абсолютно все между первым открывающим признаком и  последним закрывающим, а ленивый учел все как нужно. Чтобы сделать  квантификатор ленивым, нужно после него поставить знак вопроса.



# Альтернативы

Альтернатива выражается конструкцией *(вариант1|вариант2)*:

```c#
string input = "Jen";
var matches = Regex.Matches(input, @"Jen(ny|nifer)?");

Console.WriteLine(Regex.IsMatch(input, @"Jenny"));  // true
```

Это выражение также устроят имена Jen и Jennifer.



# Утверждения нулевой ширины

Предназначены для задания условий *перед* и *после* совпадения и не увеличивают длину совпадения

### Просмотр вперед и назад

► Выше был пример поиска всех слов, находящихся внутри тегов <i>:

```c#
string input = "<i>This</i> is a test <i>string</i>";
var matches = Regex.Matches(input, @"<i>\w+</i>");
```

Его проблема в том, что он выбирает `<i>` и `</i>` как часть  результата: `<i>This</i>` и `<i>string</i>`. Этого  можно избежать, применив технику положительного просмотра вперед и  назад:

```c#
var matches = Regex.Matches(input, @"(?<=<i>)\w+(?=</i>)");
```

► Однако сама по себе операция просмотра не исключает элементы из  результата. В примере выше они не выбираются только из-за самого  утверждения w+.  Следующий пример показывает, что в зависимости от  утверждения, элементы из просмотра тоже могут попадать в результат:

```c#
string input = "It's 25 miles from here";
var matches = Regex.Matches(input, @"\d+\s(?=miles).*");
// Результат: 25 miles from here
```

Или пример, проверяющий, чтобы пароль был не менее шести символов и в нем была цифра в любой позиции:

```c#
string pwd = "p455w0rD";
Match m = Regex.Match(pwd, @"(?=.*\d).{6,}");
if (m.Success)
{
    Console.WriteLine($"{m.Value} is strong");
}
```

| Синтаксис | Значение                      |
| --------- | ----------------------------- |
| (?=expr)  | Положительный просмотр вперед |
| (?!expr)  | Отрицательный просмотр вперед |
| (?<=expr) | Положительный просмотр назад  |
| (?<!expr) | Отрицательный просмотр назад  |



### Привязки

Привязки позволяют указать, что искомое выражение должно находиться в начале или в конце строки:

* **^** - начало строки

  ```c#
  string input = "what you see is what you get";
  var matches = Regex.Matches(input, @"^what");
  ```

  Найдет только первый what

  ```c#
  string input = "what you see is\nwhat you get";
  var matches = Regex.Matches(input, @"^what", RegexOptions.Multiline);
  ```

  Найдет оба what за счет указания опции Multiline

* **$** - конец строки

  ```c#
  string input = "I see what I see";
  var matches = Regex.Matches(input, @"see$");
  ```

  Найдет только последний see

  ```c#
  string input = "I see\n what I see";
  var matches = Regex.Matches(input, @"see$", RegexOptions.Multiline);
  ```

  Найдет оба see за счет указания опции Multiline

В реальных примерах, например, при чтении из файла, конец строки может  быть представлен комбинацией символов \r\n и предыдущие выражения не  найдут первый see. Чтобы этого не произошло, нужно воспользоваться  командой просмотра:

```c#
string input = "I see\r\n what I see";
var matches = Regex.Matches(input, @"see(?=\r?$)", RegexOptions.Multiline);
```



### Границы слов

Когда требуется подчеркнуть, что искомое выражение должно быть самостоятельным словом, используется *утверждение границы слова* `\b`:

```c#
string input = "Wedding in Sarajevo";
var matches = Regex.Matches(input , @"in");      // 2
var matches = Regex.Matches(input , @"\bin\b");  // 1

foreach (Match m in matches)
{
    Console.WriteLine($"{m.Index}, {m.Value}");
}
```

\b дает совпадение для *начала\конца строки* и для *\W*. Это означает, что  in найдется в строке `@"Wedding#in#Sarajevo"`, но не найдется в  `@"Wedding_in_Sarajevo"`



### Группы

► Это механизм, позволяющий разбить шаблон на осмысленные фрагменты и  обращаться к ним по отдельности. Для оформления группы нужно взять  фрагмент шаблона в *круглые скобки*. Например, выделим из телефонного номера код города и сам номер:

```c#
string phone = "8 (495) 555-44-33";
var matches = Regex.Match(phone, @"\((\d+)\).(\d+-\d+-\d+)");
Console.WriteLine(matches.Groups[0]);  // 8 (495) 555-44-33
Console.WriteLine(matches.Groups[1]);  // 495
Console.WriteLine(matches.Groups[2]);  // 555-44-33

foreach (var g in matches.Groups)
{
    Console.WriteLine(g);
}
```

В случае нахождения совпадения, к группам внутри него можно обращаться  по индексу. В 0 хранится совпадение целиком. Здесь мы также использовали экранированные круглые скобки в буквальном смысле для поиска кода.

► К группам после объявления можно сразу же обращаться в этом же  регулярном выражении. Найдем слова, которые начинаются и заканчиваются  на одну и ту же букву:

```c#
string phone = "lil peep sponge bob";
var matches = Regex.Matches(phone, @"\b(\p{L})\p{L}+\1\b");

foreach (var m in matches)
{
    Console.WriteLine(m);
}
```

Здесь первая группа **(\p{L})** захватывает первую букву слова. Затем с помощью **\p{L}+** мы указываем, что дальше может идти любое количество букв. И наконец  завершаем шаблон первой буквой, обращаясь к ней через первую группу с  помощью конструкции **\1** - \номер_группы. \b использовано для подчеркивания того, что требуются полные слова (иначе, например, tetris выдал бы tet).

► Группам можно давать имена **(?'gname'expr)** и обращаться к ним потом по этим именам **k'gname'** вместо использования индексов:

```c#
string phone = "lil peep sponge bob";
string pattern =
    @"\b"                 +
    @"(?'firstLet'\p{L})" +
    @"\p{L}+"             +
    @"\k'firstLet'"       +
    @"\b";

var matches = Regex.Matches(phone, pattern);
```

Заодно здесь продемонстрирован способ формирования шаблона, удобный при длинных условиях.