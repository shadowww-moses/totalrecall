# Замена текста

► Метод `Regex.Replace` позволяет использовать при замене регулярные выражения, что бывает удобнее, чем метод Replace на строке:

```c#
string str = "catapult the dog";
string mod1 = str.Replace("cat", "dog");  // dogapult the dog
string mod2 = Regex.Replace(str, @"\bcat\b", @"dog");  // catapult the dog
```

За счет возможности указать с помощью РВ, что cat должно быть отдельным словом, мы получили правильный результат. Методы замены не изменяют исходную строку

► С помощью конструкции `$0` можно ссылаться на *текущее* найденное совпадение в *тексте-замене*:

> Внимание! Ссылаться не в самом шаблоне поиска, а именно в *тексте-замене*

```c#
string str = "5 plus 10 makes 15";
string mod = Regex.Replace(str, @"\d+", @"<$0>");
Console.WriteLine(mod);  // <5> plus <10> makes <15>
```

Таким образом удобно что-то "приделывать" к искомым фрагментам - каждый найденный элемент будет трансформирован

► При формировании группы в шаблоне поиска, конструкции `$1`, `$2`, `$3` (и т.д.), `${имяГруппы}` позволяют пользоваться значением этой группы в *тексте-замене*. Например, есть задача - перенести текст из тела тега в его атрибуты:

```c#
string xml1 = "<msg>Hello, Regexp!</msg>";
string xml2 = "<msg id=5>Hello, Regexp!</msg>";

string find = @"<(?'tag'\w+)(?'attr'.*)>(?'text'.+)</\k'tag'>";
string replace = @"<${tag}${attr} value=""${text}""/>";
            
var rep = Regex.Replace(xml1, find, replace);
Console.WriteLine(rep);  // <msg value="Hello, Regexp!"/>
rep = Regex.Replace(xml2, find, replace);
Console.WriteLine(rep);  // <msg id=5 value="Hello, Regexp!"/>
```

> Разбор `<(?'tag'\w+)(?'attr'.*)>(?'text'.+)</\k'tag'>`:
>
> `<(?'tag'\w+)` - < значит начинается тег. Захватываем имя тега - это любые буквы после <, их должно быть больше 0 - и оформляем их в группу с именем tag
>
> Далее формируем группу атрибутов`(?'attr'.*)>` Это любые символы после имени тега и до закрывающего > Атрибутов может и не быть, как в случае с xml1, а значит перед закрывающей > может быть 0 символов, поэтому используем *
>
> Далее просто - текст это любые символы `(?'text'.+)</` до закрывающего </msg> причем / это не спецсимвол, его не надо экранировать
>
> Ну и в конце берем значение группы tag через `\k'tag'` и `>` закрывающая тег скобка. Так у нас  <msg> будет закрываться только </msg>, а не каким-нибудь </mesg>

► Метод Replace может вместо шаблона замены принимать функцию, которая получает текущее  совпадение и вычисляет значение-замену:

```c#
string str = "5 plus 10 makes 15";
string rep = Regex.Replace(str, @"\d+", 
    (num) => (int.Parse(num.Value) * 2).ToString());
Console.WriteLine(rep);
```

Здесь в функцию попадает объект Match, поэтому из него нужно извлечь значение и провести явное преобразование.

Данная перегрузка Replace полезна, когда выражение для замены надо вычислить как-то хитро и ресурсов обычного шаблона не хватает. Параметр, в который мы кладем функцию, имеет тип делегат `MatchEvaluator`



# Разделение текста

Производится с помощью метода `Split`. Он возвращает массив строк `string []`

По умолчанию сами разделители не попадают в результат:

```c#
string str = "a5b4c3";
var res = Regex.Split(str, @"\d");
foreach (var r in res)
{
    Console.WriteLine(r);  // a b c
}

string str = "oneTwoThree";
var res = Regex.Split(str, @"\p{Lu}");  // one wo hree
```

Но можно включить разделители, если использовать технику *положительного просмотра вперед*:

```c#
string str = "oneTwoThree";
var res = Regex.Split(str, @"(?=\p{Lu})");  // one Two Three
```



# Таймаут для регулярного выражения

Начиная с версии фреймворка 4.5 для регулярного выражения можно  настроить ограничение по времени вычисления. Это может быть полезно в  случае поступления в программу некорректного регулярного выражения  извне, которое может ее повесить. Таймаут задается в четвертом параметре методов поиска:

```c#
string input = "Good mood";
var matches = Regex.Matches(
    input, @"\w?ood",
    RegexOptions.None,
	TimeSpan.FromSeconds(10)
);
```



# Скомпилированные регулярные выражения

Если есть текст, в котором требуется многократно искать разные  совпадения, то можно воспользоваться техникой скомпилированных  регулярных выражений. Для этого надо создать объект Regex со специальным параметром `RegexOptions.Compiled`:

```c#
string input = "Good mood";
var reg = new Regex(input, RegexOptions.Compiled);

// Теперь вызываем метод уже на объекте, а не на классе
var matches = reg.Matches(@"\w?ood");

foreach (Match m in matches)
{
    Console.WriteLine($"{m.Index}, {m.Value}");
}
```

Стоит отметить, что регулярные выражения и так работают очень быстро. Поэтому данный способ используется не часто.