Для работы с регулярными выражениями нужно подключить пространство имен `System.Text.RegularExpressions`

`Regex` - основной класс для работы с регулярками. Он имеет несколько статических методов:



# Метод Match

► Это главное средство поиска шаблонов в строках:

```c#
string input = "Good mood";
string pattern = @"\w?ood";
Match m = Regex.Match(input, pattern);
```

Он возвращает объект типа `Match`, который содержит  первое совпадение указанному шаблону. В данном случае мы искали все  слова, которые заканчиваются на odd (либо самостоятельное слово ood),  поэтому нашли слово Good. Оно содержится в свойстве `Value` объекта Match. Вот список некоторых полезных свойств этого объекта:

| Свойство  | Назначение                                       |
| --------- | ------------------------------------------------ |
| m.Value   | Элемент, в котором найдено совпадение (Good)     |
| m.Success | Найдено совпадение или нет (true)                |
| m.Index   | Позиция, с которой найдено совпадение (0)        |
| m.Length  | Длина элемента, в котором найдено совпадение (4) |
| m.Count   | Количество совпадений (2)                        |

► Альтернативой свойству `Success` является метод `IsMatch`, который сразу возвращает bool вместо объекта Match:

```c#
if (Regex.IsMatch(input, @"\w?ood"))
{
    Console.WriteLine("Pattern detected");
}
```

► Метод `NextMatch` позволяет выбрать следующее совпадение:

```c#
Match nextM = m.NextMatch();  // .Value == mood
```

Если этого «следующего» совпадения нет, метод вернет не null, а тоже объект Match, просто с пустым свойством Value.



# Метод Matches

Если требуется получить все совпадения с целью дальнейшего обхода, лучше воспользоваться методом `Matches`, который вернет их в виде массива:

```c#
string input = "Good mood";
var matches = Regex.Matches(input, @"\w?ood");

foreach (Match m in matches)
{
    Console.WriteLine($"{m.Index}, {m.Value}"); // 0, Good; 5, mood
}
```



# Опции поиска

► Третий параметр методов `Match` и `Matches` позволяет задать опции для поиска. Например, опция поиска *без учета регистра*:

```c#
string input = "GOOD MOOD";
string pattern = @"\w?ood";
Console.WriteLine(Regex.IsMatch(input, pattern)); // false
Console.WriteLine(Regex.IsMatch(input, pattern, RegexOptions.IgnoreCase));  // true
```

► Другие опции:

| Опция      | Назначение                                                   | Код  |
| ---------- | ------------------------------------------------------------ | ---- |
| None       | Значение по умолчанию                                        |      |
| IgnoreCase | Игнорировать регистр                                         | i    |
| SingleLine | Многострочный источник воспринимается как единая строка. Символ `.` в этом режиме означает абсолютно любой символ | s    |
| Multiline  | Многострочный источник воспринимается как действительно многострочный. Символы `^` и `$` означают начало и конец каждой строки | m    |

► Опции можно *включать* `(?code)` и *отключать* `(?-code)` «на ходу» прямо в выражении:

```c#
string input = "AAaa";
var matches = Regex.Matches(input, @"(?i)a(?-i)a");  // Aa
```

Здесь мы ищем две буквы а, причем для первой регистр не важен (?i), а  для второй важен (?-i). То есть первая может быть как маленькой, так и  большой, а вторая обязательно маленькой, поэтому выбирается Aa из  середины.