Компилятор тут https://www.masm32.com/ Установка простая, потом желательно добавить в Path путь до bin



# О чем тут?

* Демка простой программы
* Подключение внешних файлов (например, с константами и объявлением переменных)
* Объявление дополнительных файлов с процедурами
* Компиляция и линковка нескольких файлов
* Ключ `/coff` компиляции
* Что такое слово, двойное слово
* `.flat`, `near`

# Памятка

* Байт, слово, двойное слово

  ```
  DB - байт, 8 бит
  DW - слово (байт * 2 = 16 бит), dword
  DD - двойное слово (слово * 2 = 32 бит)
  ```



# Вопросы

- [ ] Зачем вообще нужны сегменты?

  Кроме сегмента данных и сегмента кода можно добавить и другие. Я добавлял пустой например, менял местами СД и СК, ничего не происходило, ошибок не было.

# Компиляция и линковка

```
ml /c /coff myprog.asm
link /subsystem:windows myprog.obj
```

Ключ `/coff` используется везде у Пирогова, означает `Common Object File Format`. Это формат объектных файлов для Windows (есть еще для DOS, ключ `/omf`). Соответственно, `/coff` и `/subsystem:windows` должны идти вместе.

Компиляция нескольких файлов:

```
ml /c /coff myprog.asm submodule.asm
```

Линковка нескольких объектных файлов:

```
link /subsystem:windows myprog.obj submodule.obj
```

Когда программа состоит из нескольких объектных модулей, один из них всегда является главным. При линковке он должен указываться первым. 



# Примеры

## Простая программа

```asm
.586P
.model flat, stdcall
; комментарий
_data segment
_data ends

_text segment
	start:
		ret
_text ends
end start
```

Количество табов не важно. Имена сегментов - тоже. Могло быть `_data2` или `data`. Регистр букв - тоже похоже не важен - `.586p` тоже работает.

## Подключение других файлов

Сделаем два файла - один с объявлением констант, `const.inc` (расширение inc - просто правила хорошего тона)

```asm
cons1 equ 1000
cons2 equ 2000
```

Второй файл - с переменными, `data.inc`:

```asm
dat1 dword 0
dat2 dword 0
```

Подключаются файлы командой `include`:

```asm
.586P
.model flat, stdcall

include const.inc

_data segment
	include data.inc
_data ends

_text segment
	start:
		mov eax, cons1
		shl eax, 1
		mov dat1, eax
		ret
_text ends
end start
```

### Эксперименты

* Если вынести подключение `data.inc` из сегмента данных, будут ошибки:

  ```
  data.inc(1) : error A2034: must be in segment block
  data.inc(2) : error A2034: must be in segment block
  prog.asm(14) : error A2006: undefined symbol : dat1
  ```

  То есть похоже что переменные можно объявлять только строго в сегменте данных.

  UPD. Нет. Можно объявить переменную в сегменте кода тоже. Похоже, важно чтобы она была определена именно в сегменте, а в каком - наверное неважно.

* Подключение констант в сегменте данных ошибок не дает.

* Нужно обязательно указывать начальное значение при объявлении переменной

* Если разделить `end start` на разные строки, будет ошибка:

  ```
  LINK : error LNK2001: unresolved external symbol _WinMainCRTStartup
  prog.exe : fatal error LNK1120: 1 unresolved externals
  ```

* Метку `start` можно переименовать и это ничего не поменяет.

* Если убрать метку `start` вообще, будет ошибка

  ```
  LINK : error LNK2001: unresolved external symbol _WinMainCRTStartup
  prog.exe : fatal error LNK1120: 1 unresolved externals
  ```

  - [ ] Получается, что хоть какая-то метка в сегменте кода обязательно должна быть?

* Можно добавить еще сегменты с любым именем

* Можно поменять местами сегменты данных и кода, ошибки не было

## Несколько объектных файлов

Подпрограммы можно разбросать по разным файлам. Например:

```asm
.586p
.model flat, stdcall

public proc1

_text segment
	proc1 proc
		mov eax, 1000
		ret
	proc1 endp
_text ends

end
```

Можно заметить, что `end` снабжается суффиксом в зависимости от того, окончание чего он означает. `ends` - конец сегмента, `endp` - конец процедуры. Процедура, предназначенная для пользования извне отмечается как `public`.

Основной модуль:

```asm
.586p
.model flat, stdcall

extern proc1@0:near

_data segment	
_data ends

_text segment
	start:
		call proc1@0
		ret
_text ends

end start
```

Здесь тоже надо указать внешние процедуры, используя `extern`. Значение после `@` означает количество байт, которые надо передать процедуре в качестве параметров. Поскольку параметров нет, то здесь 0.

Тип `near` означает, что "вызов процедуры будет происходить в пределах одного сегмента", а `far` - что из другого сегмента.

Тут появляются два вопроса: 

- [ ] Зачем вообще нужны сегменты (уже был раньше)

- [ ] Что значит "в пределах одного сегмента"

  То есть например, допустим у нас объявлено три сегмента A, B, C. Если вызываем процедуру только в сегменте A, тогда пишем near, а если в A и B, тогда far?

Как бы то ни было, в Windows модель памяти - `flat`, т.е. "сплошная", "плоская" и память процесса поэтому можно рассматривать как единый непрерывный массив, один сегмент, поэтому наверное можно только `near` использовать.

- [ ] Но с другой стороны, мы же объявляем в коде разные сегменты, как минимум два на данный момент. Как это вяжется с идеей flat?