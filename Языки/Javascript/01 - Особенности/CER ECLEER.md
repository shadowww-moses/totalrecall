# Сэр Эклер

Информация, проливающая свет на то, как работают замыкания и немножко на то, что происходит при выполнении кода. Детальность и точность не 100%, но общая картина для представления обрисована правильно.

**CER EC.LE.ER** 

Первое слово означает Context, Environment, Record

А второе - полные их названия - Execution Context, Lexical Environment, Environment Record

Это три объекта, которые создаются в памяти при выполнении любого кода.

<img src="img/СER ECLEER.png" alt="СER ECLEER" style="zoom:80%;" />

На примере следующего кода разберем, что все это значит:

```javascript
let name = "JohNy Lain";

function greet(name) {
  let message = `Hello, ${name}!`;
  console.log(message);
}

let goodbye = function(name) {
  let message = `Goodbye, ${name}!`;
  console.log(message);
};

function makeClosure() {
  let login = "username";
  let password = "12345";

  return function() {
    console.log(login + " " + password);
  }
}

greet(name);
goodbye(name);

let info = makeClosure();
info();
```

* Когда начинает выполняться скрипт, создаются объекты ExecutionContext, LexicalEnvironment и EnvironmentRecord. Как они взаимосвязаны, показано на рисунке. Это получается глобальные объекты, потому что они относятся к целому скрипту
* Объект ExecutionContext помещается в стек
* Перед непосредственно выполнением проходит стадия *лексического анализа* - движок просматривает код и ищет идентификаторы переменных и функций
* В данном случае он находит идентификатор `name` - переменная с именем, `greet` - идентификатор функции, `goodbye` - переменная (именно переменная, не функция), `makeClosure` - функция, `info` - переменная
* Все эти идентификаторы помещаются в качестве полей в объект EnvironmentRecord, то есть в нем появляются поля с названиями name, greet, goodbye, makeClosure, info
* Для функций, являющихся Function Declaration (в данном случае greet и makeClosure, но не goodbye) создаются объекты функций - служебного типа FunctionObject и помещаются в соответствующие поля ER. У каждого такого FunctionObject есть поле `scope`, в который сейчас помещается ссылка на объект LexicalEnvironment готовящегося к выполнению кода (сейчас это код скрипта, глобальный). Потом, когда функция будет вызываться, для нее тоже создастся ECLEER и в outer LE функции будет помещено значение из scope - таким образом как раз функция и знает об "объемлющем" ее коде и всех его переменных - так работают замыкания
* То, что объявлено внутри функций, например, переменные `message`, `login`, `password` - движок сейчас не обращает на них внимания, потому что просматривает только код, который непосредственно должен выполниться. Все же эти `message`, `login`, `password` будут найдены только когда начнут выполняться функции, в которых они объявлены
* Когда все идентификаторы найдены, приходит время выполнить код
* В переменную name записывается значение JohNy Lain
* Вычисляется значение для переменной goodbye. То есть создается FunctionObject, у которого тоже есть scope, и все остальное как я писал выше - в этот scope попадает ссылка на LE скрипта, FunctionObject помещается в поле goodbye объекта ER скрипта
* Далее вызывается функция greet. Для нее создается ECLEER. Ее EC добавляется в стек. В outer LE кладется значение из scope - так функция greet в процессе своего выполнения получает доступ ко всем переменным, хранящимся в ER скрипта. Проходит стадия лексического анализа, обнаруживается идентификатор переменной message, помещается в ER функции. Начинается выполнение кода функции. Вычисляется значение для переменной message и кладется в соответствующее поле ER
* Когда функция greet отработает, ее EC выбрасывается из стека. Поскольку кроме как из него на объекты LE и ER функции ссылок не было, они перестают быть доступными и подвергаются уборке мусора
* С goodbye все то же самое
* Когда выполняется makeClosure, все происходит аналогично за исключением одного момента. Поскольку в makeClousure создается другая функция, эта другая функция имеет ссылку на LE makeClosure. makeClosure возвращает эту функцию как результат своей работы и EC makeClosure из стека выбрасывается. Но поскольку эта функция хранит в своем LE, поле outer, ссылку на LE makeClosure, то он не подвергается уборке мусора. Вот так и получается замыкание.



Я попытался поподробнее расписать как это все работает, но не знаю, будет ли это понятно, если я вдруг что забуду, пока не забуду. Даже сейчас это выглядит немного запутанно. То есть детальное объяснение какое-то громоздкое. Поэтому в общих чертах попробую еще написать "повыше":

* Любой код, который сейчас будет исполняться, получает объекты ECLEER
* Объект EC помещается в стек
* Перед выполнением происходит лексический анализ этого кода и заполнение ER найденными идентификаторами
* В LE попадает ссылка на LE объемлющего кода и поэтому код "видит" все вещи "сверху" по цепочке
* После выполнения кода, его объект EC выбрасывается из стека, поэтому его LE и ER тоже теряются и убираются сборщиком мусора. Но если на них остались другие ссылки, тогда они остаются в памяти и доступны тому коду, который имеет на них ссылку и только ему. Так работают замыкания. Обычно "выполняемый код" - это вызов функции. А функция - это объект специального типа FunctionObject, который имеет поле scope. В эту переменную попадает ссылка на объект LE кода, в котором был создан FunctionObject. Поэтому если FunctionObject уходит "вовне", то уносит с собой и ссылку на тот участок, в котором был создан.



Использованная информация:

[Илья Кантор](https://learn.javascript.ru/closure)

[Хабр](https://habr.com/ru/post/279421/)