Напишем небольшой пример:

```javascript
function showName() {
  let name = 'JohNy';
  console.log(this.name + ' and ' + name);
}

let name = 'Sam';

let user = {
  name: 'Alice',
  showName
};
```

И рассмотрим на нем поведение this:

```javascript
// Обычный режим, no strict
user.showName();  // Alice and JohNy
user['showName']();  // Alice and JohNy
console.log(this.name);  // Sam
showName();  // Sam and JohNy

(user.showName)();  // Alice and JohNy
(user.showName = user.showName)();  // Sam and JohNy

let displayName = user.showName;
displayName();  // Sam and JohNy
```

```javascript
'use strict';
user.showName();  // Alice and JohNy
user['showName']();  // Alice and JohNy
console.log(this.name);  // Sam
showName();  // TypeError: this is undefined

(user.showName)();  // Alice and JohNy
(user.showName = user.showName)();  // TypeError: this is undefined

let displayName = user.showName;
displayName();  // TypeError: this is undefined
```

Как видно, в зависимости от режима результаты отличаются. Разберемся, почему.

## Вычисление this

Если присмотреться к примеру, то хорошо видно, что функция `showName()` использует два имени - не только свою собственную переменную `name`, но и еще `name` какого-то объекта, на который указывает this.

> Когда мы вызываем метод `showName` *на объекте*, то ожидаем, что он возьмет значение `name` именно из этого объекта - объекта, на котором его вызвали, а не какого-то другого. 

Из первого набора примеров заметно, что при вызове `user.showName()`  `this.name`  имеет значение Alice - то есть this указывает на объект user. При остальных вызовах `this.name` имеет значение Sam - то есть this указывает на глобальный объект, а в случае строгого режима вообще возникает ошибка.

Итак,

> this вычисляется динамически, во время выполнения кода. 

К тому же, в команде `console.log(this.name);` this используется в *глобальном коде*, а в остальных - в *коде функции*. От этого тоже зависит, какое он примет значение.

> this в глобальном коде всегда указывает на сам глобальный объект

> Значение this в коде функции зависит от того, как функция была вызвана

## Способы вызова функции

В примере показано много способов вызвать функцию. Объединяет и различает их один важный факт - какой тип получится в результате каждой манипуляции. И от того, какой это будет тип, зависит то, как будет обработан вызов.

А типы эти мы условно разделим на `ReferenceType` и на все остальные, то есть "не-ReferenceType".

## ReferenceType

Если взять псевдокод, то у значения типа ReferenceType следующая структура:

```javascript
valueOfReferenceType {
  base: <base object>,
  propertyName: <property name>
};
```

Чтобы лучше понять, что хранится в этих свойствах, рассмотрим пример:

```javascript
var foo = 10;
function bar() { console.log('this is not easy'); }

bar();
console.log(foo);
```

Здесь определены два идентификатора - foo и bar и определены они в глобальном коде. Значит, когда этот код начнет выполнение, сперва в его объекте GlobalObject появятся два поля - с именами foo и bar.

> Примечание: здесь важный момент в том, что из-за множества источников от разных дат я не могу точно сказать, как например называется объект, содержащий идентификаторы, объявленные в глобальном коде. Допустим, когда выполняется функция, для нее создаются ExecutionContext, LexicalEnvironment и EnvironmentRecord. А когда выполняется глобальный код, то для него кто-то пишет уже ExecutionContext, GlobalEnvironment и GlobalObject. Так что по именам пока не уверен - надо искать самостоятельно в спеке. Но основной принцип я понял. И важно понимать, что что бы тут не было написано, как бы этот объект с идентификаторами не назывался - EnvironmentRecord или GlobalObject, его суть одинаковая - объект, в котором хранятся идентификаторы выполняющегося в данный момент кода.

Затем, когда эти идентификаторы будут использоваться - в данном случае, foo будет выводиться в консоль, а функция bar вызываться - то сперва их значения нужно будет *вычислить*, то есть понять, а что же в них лежит. Запустится поиск этих идентификаторов по цепи объектов LexicalEnvironment и когда в ближайшем LexicalEnvironment найдутся свойства, имена которых такие же как у искомых идентификаторов, то создадутся два значения типа ReferenceType:

> Опять же, тут вероятно никакой цепи не будет, потому что глобальный объект находится в самом ее основании и дальше уже ничего нет, но концепция поиска тем не менее важна

```javascript
// псевдокод для демонстрации сути
var fooReference = {
  base: global,
  propertyName: 'foo'
};
 
var barReference = {
  base: global
  propertyName: 'bar'
};
```

у которых в свойстве `base` будет global - ссылка на глобальный объект (потому что найдены они были именно в нем), а в `propertyName` - их имя.

> К слову, "ссылка на глобальный объект" немного меня смущает, потому что а может быть окажется, что не на сам глобальный объект, а на связанный с ним объект переменных? Хотя может быть, что как раз на глобальный, и просто когда выполняются какие-то операции, то они уже от этой ссылки получают ссылки на связанные с ним инфраструктурные объекты. Но опять же, это уже совсем микродетали, на понимание сути не особо я думаю влияет

Теперь значение идентификатора `bar` в строке `bar();` вычислено и имеет тип ReferenceType с ссылкой на базовый объект и именем его поля, соответствующего идентификатору. Пришло время круглых скобок `()`, которые запустят операцию выполнения. Таким образом, единственная строка `bar();` представляет две команды - сперва поиск идентификатора, а потом выполнение.

## Выполнение ReferenceType

► Про ReferenceType важно знать следующую вещь:

> Выполнение ReferenceType характеризуется тем, что this для подлежащего выполнению кода содержит ссылку из свойства base ReferenceType

Для нашего примера это означает, что значением this для функции bar будет ссылка на глобальный объект.

Но если выполняется не-ReferenceType, то никакого base не существует, а значит this остается незаданным (undefined). В нестрогом режиме в этом случае this получает ссылку на глобальный объект, а в строгом остается undefined, поэтому примеры из начала статьи выдают такие результаты.

► Тип ReferenceType получается в результате двух операций:

* Разрешение имени идентификатора (то есть поиск идентификатора по цепочке лексических окружений)
* Получение доступа к свойству. При этом в base сразу попадает объект, на котором вызывается метод, то есть мы как бы явно подсказываем движку, какой объект нужно использовать в качестве значения this

► А теперь еще раз посмотрим на примеры из начала статьи с учетом полученных знаний:

```javascript
'use strict';
user.showName();  // Alice and JohNy
user['showName']();  // Alice and JohNy
console.log(this.name);  // Sam
showName();  // TypeError: this is undefined

(user.showName)();  // Alice and JohNy
(user.showName = user.showName)();  // TypeError: this is undefined
[+] user.showName = user.showName;
[+] user.showName();  // Alice and JohNy

let displayName = user.showName;
displayName();  // TypeError: this is undefined
```

и разберем их отдельно:

```javascript
user.showName();  // Alice and JohNy
user['showName']();  // Alice and JohNy
```

Обе эти операции - получение доступа к свойству. А это, как было написано выше, приводит к получению типа ReferenceType, поэтому все работает ожидаемо.

```javascript
console.log(this.name);  // Sam
```

Здесь this используется не в коде функции, а в глобальном коде, а в этом случае this всегда указывает на глобальный объект.

```javascript
showName();  // TypeError: this is undefined
```

Здесь идет обычный вызов функции, который, как было в объяснении с функцией bar, включает в себя две операции:  запускается поиск идентификатора `showName`. Он обнаруживается в глобальном объекте. Создается ReferenceType и в его base помещается глобальный объект. Затем ReferenceType выполняется и в функцию в качестве this попадает его base - то есть глобальный объект.

СТОП! А почему тогда undefined? 



