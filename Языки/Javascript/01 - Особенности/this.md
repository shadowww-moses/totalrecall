Короче говоря, с большой вероятностью все, что дальше написано - филькина грамота, в которой вперемешку описаны и реальные процессы, и домыслы, поэтому читать и дорабатывать это можно, но с практической точки достаточно прочитать только последний раздел, чтобы просто понимать как правильно пользоваться this, а не как оно вычисляется под капотом.

Чтобы понять, лучше наверное дрочить спеку, потому что иначе все равно все объяснения выглядят СЛИШКОМ мутно, а времени занимают просто ДОХУИЩА. Так что чем тратить его на чьи-то объяснения, воистину лучше почитать свежую спеку https://www.ecma-international.org/ecma-262/10.0/index.html



Напишем небольшой пример:

```javascript
function showName() {
  let name = 'JohNy';
  console.log(this.name + ' and ' + name);
}

let name = 'Sam';

let user = {
  name: 'Alice',
  showName
};
```

И рассмотрим на нем поведение this:

```javascript
// Обычный режим, no strict
user.showName();  // Alice and JohNy
user['showName']();  // Alice and JohNy
console.log(this.name);  // Sam
showName();  // Sam and JohNy

(user.showName)();  // Alice and JohNy
(user.showName = user.showName)();  // Sam and JohNy

let displayName = user.showName;
displayName();  // Sam and JohNy
```

```javascript
'use strict';
user.showName();  // Alice and JohNy
user['showName']();  // Alice and JohNy
console.log(this.name);  // Sam
showName();  // TypeError: this is undefined

(user.showName)();  // Alice and JohNy
(user.showName = user.showName)();  // TypeError: this is undefined

let displayName = user.showName;
displayName();  // TypeError: this is undefined
```

Как видно, в зависимости от режима результаты отличаются. Разберемся, почему.

## Вычисление this

Если присмотреться к примеру, то хорошо видно, что функция `showName()` использует два имени - не только свою собственную переменную `name`, но и еще `name` какого-то объекта, на который указывает this.

> Когда мы вызываем метод `showName` *на объекте*, то ожидаем, что он возьмет значение `name` именно из этого объекта - объекта, на котором его вызвали, а не какого-то другого. 

Из первого набора примеров заметно, что при вызове `user.showName()`  `this.name`  имеет значение Alice - то есть this указывает на объект user. При остальных вызовах `this.name` имеет значение Sam - то есть this указывает на глобальный объект, а в случае строгого режима вообще возникает ошибка.

Итак,

> this вычисляется динамически, во время выполнения кода. 

К тому же, в команде `console.log(this.name);` this используется в *глобальном коде*, а в остальных - в *коде функции*. От этого тоже зависит, какое он примет значение.

> this в глобальном коде всегда указывает на сам глобальный объект

> Значение this в коде функции зависит от того, как функция была вызвана

## Способы вызова функции

В примере показано много способов вызвать функцию. Объединяет и различает их один важный факт - какой тип получится в результате каждой манипуляции. И от того, какой это будет тип, зависит то, как будет обработан вызов.

А типы эти мы условно разделим на `ReferenceType` и на все остальные, то есть "не-ReferenceType".

## ReferenceType

Если взять псевдокод, то у значения типа ReferenceType следующая структура:

```javascript
valueOfReferenceType {
  base: <base object>,
  propertyName: <property name>
};
```

Чтобы лучше понять, что хранится в этих свойствах, рассмотрим пример:

```javascript
var foo = 10;
function bar() { console.log(this + ' is not easy'); }

bar();
console.log(foo);
```

Здесь определены два идентификатора - foo и bar и определены они в глобальном коде.

> К идентификаторам относятся имена переменных, функций, параметров функций и неявные свойства глобального объекта)

Значит, когда этот код начнет выполнение, сперва в его объекте GlobalObject появятся два поля - с именами foo и bar.

> Примечание: здесь важный момент в том, что из-за множества источников от разных дат я не могу точно сказать, как например называется объект, содержащий идентификаторы, объявленные в глобальном коде. Допустим, когда выполняется функция, для нее создаются ExecutionContext, LexicalEnvironment и EnvironmentRecord. А когда выполняется глобальный код, то для него кто-то пишет уже ExecutionContext, GlobalEnvironment и GlobalObject. Так что по именам пока не уверен - надо искать самостоятельно в спеке. Но основной принцип я понял. И важно понимать, что что бы тут не было написано, как бы этот объект с идентификаторами не назывался - EnvironmentRecord или GlobalObject, его суть одинаковая - объект, в котором хранятся идентификаторы выполняющегося в данный момент кода.

Затем, когда эти идентификаторы будут использоваться - в данном случае, foo будет выводиться в консоль, а функция bar вызываться - то запустится поиск этих идентификаторов по цепи объектов LexicalEnvironment и когда в ближайшем LexicalEnvironment найдутся свойства, имена которых такие же как у искомых идентификаторов, то создадутся два значения типа ReferenceType:

> Опять же, тут вероятно никакой цепи не будет, потому что глобальный объект находится в самом ее основании и дальше уже ничего нет, но концепция поиска тем не менее важна

```javascript
// псевдокод для демонстрации сути
var fooReference = {
  base: global,
  propertyName: 'foo'
};
 
var barReference = {
  base: global
  propertyName: 'bar'
};
```

у которых в свойстве `base` будет global - ссылка на глобальный объект (потому что найдены они были именно в нем), а в `propertyName` - их имя.

> К слову, "ссылка на глобальный объект" немного меня смущает, потому что а может быть окажется, что не на сам глобальный объект, а на связанный с ним объект переменных? Хотя может быть, что как раз на глобальный, и просто когда выполняются какие-то операции, то они уже от этой ссылки получают ссылки на связанные с ним инфраструктурные объекты. Но опять же, это уже совсем микродетали, на понимание сути не особо я думаю влияет

Теперь значение идентификатора `bar` в строке `bar();` вычислено и имеет тип ReferenceType с ссылкой на базовый объект и именем его поля, соответствующего идентификатору. Пришло время круглых скобок `()`, которые запустят операцию выполнения. Таким образом, единственная строка `bar();` представляет две команды - сперва поиск идентификатора, а потом выполнение.

## Выполнение ReferenceType

► Про ReferenceType важно знать следующую вещь:

> Выполнение ReferenceType характеризуется тем, что this для подлежащего выполнению кода содержит ссылку из свойства base ReferenceType

Для нашего примера это означает, что значением this для функции bar будет ссылка на глобальный объект:

```javascript
function bar() { console.log(this + ' is not easy'); }
bar();
```

БЛЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯТЬ

► Тип ReferenceType получается в результате двух операций:

* Разрешение имени идентификатора (то есть поиск идентификатора по цепочке лексических окружений)
* Получение доступа к свойству. При этом в base сразу попадает объект, на котором вызывается метод, то есть мы как бы явно подсказываем движку, какой объект нужно использовать в качестве значения this

► А теперь еще раз посмотрим на примеры из начала статьи с учетом полученных знаний:

```javascript
function showName() {
  let name = 'JohNy';
  console.log(this.name + ' and ' + name);
}

let name = 'Sam';

let user = {
  name: 'Alice',
  showName
};
```

* Обычный режим:

  ```javascript
  user.showName();  // Alice and JohNy
  user['showName']();  // Alice and JohNy
  console.log(this.name);  // Sam
  showName();  // Sam and JohNy
  
  (user.showName)();  // Alice and JohNy
  (user.showName = user.showName)();  // Sam and JohNy
  
  let displayName = user.showName;
  displayName();  // Sam and JohNy
  ```

  ```javascript
  user.showName();  // Alice and JohNy
  user['showName']();  // Alice and JohNy
  ```

  Обе эти операции - получение доступа к свойству. А это приводит к получению типа ReferenceType, с base равным объекту перед точкой/скобками, поэтому все работает ожидаемо.

  ```javascript
  console.log(this.name);  // Sam
  ```

  Здесь this используется *не в коде функции, а в глобальном коде*, а в этом случае this всегда указывает на глобальный объект.

  ```javascript
  showName();  // Sam and JohNy
  ```

  Здесь идет обычный вызов функции, который, как было в объяснении с функцией bar, включает в себя две операции:  запускается поиск идентификатора `showName`. Он обнаруживается в глобальном объекте. Создается ReferenceType и в его base помещается глобальный объект. Затем ReferenceType выполняется и в функцию в качестве this попадает его base - то есть глобальный объект.

* Строгий режим:

  ```javascript
  'use strict';
  user.showName();  // Alice and JohNy
  user['showName']();  // Alice and JohNy
  console.log(this.name);  // Sam
  showName();  // TypeError: this is undefined
  
  (user.showName)();  // Alice and JohNy
  (user.showName = user.showName)();  // TypeError: this is undefined
  [+] user.showName = user.showName;
  [+] user.showName();  // Alice and JohNy
  
  let displayName = user.showName;
  displayName();  // TypeError: this is undefined
  ```

  

и разберем их отдельно:

```javascript
user.showName();  // Alice and JohNy
user['showName']();  // Alice and JohNy
```

Обе эти операции - получение доступа к свойству. А это, как было написано выше, приводит к получению типа ReferenceType, поэтому все работает ожидаемо.

```javascript
console.log(this.name);  // Sam
```

Здесь this используется не в коде функции, а в глобальном коде, а в этом случае this всегда указывает на глобальный объект.

```javascript
showName();  // TypeError: this is undefined
```

Здесь идет обычный вызов функции, который, как было в объяснении с функцией bar, включает в себя две операции:  запускается поиск идентификатора `showName`. Он обнаруживается в глобальном объекте. Создается ReferenceType и в его base помещается глобальный объект. Затем ReferenceType выполняется и в функцию в качестве this попадает его base - то есть глобальный объект.

СТОП! А почему тогда undefined? 



# Итого

Если не выебываться и вызывать функцию на объекте через точку или скобки, то this будет указывать на вызывающий объект и никаких проблем не будет.

Если в классе есть метод, использующий this, и этот метод передается для выполнения куда-то еще, но надо либо использовать .bind, чтобы зафиксировать this на текущий объект, либо использовать функцию-стрелку, потому что она всегда берет this из места, в котором была объявлена.