# Что такое промисы

Промис - это специальный объект следующего вида:

```javascript
let promise = new Promise(function(resolve, reject) {
  // Код промиса
});
```

В функцию-конструктор промиса мы передаем колбэк с кодом, который нам надо выполнить. А промис, в свою очередь, передает нашему колбэку два своих колбэка - через параметры `resolve`  и `reject` (хотя можно дать им любые другие имена по желанию, например, success и failure). И в нашем коде мы обязательно должны вызвать **один** из них: `resolve` в случае удачного выполнения наших задумок и `reject` в случае неудачи. В первом случае нужно передать в колбэк данные, являющиеся результатом работы, а во втором - объект ошибки (хотя можно и просто какое-нибудь сообщение, но передавать объект ошибки - грамотнее).

Результат работы в обоих случаях должен быть представлен одним параметром, то есть нужно вызывать `resolve(data)` или `reject(error)`. Можно вообще ничего не передавать. Но если передать больше одного параметра, лишние проигнорируются.

Примеры:

```javascript
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve("done"), 1000);
});
```

```javascript
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => reject(new Error("Whoops!")), 1000);
});
```

```javascript
new Promise(function(resolve, reject) {
  console.log('Промис начал выполнение');
  let min = 0;
  let max = 10;
  let rand = Math.floor(min + Math.random() * (max + 1 - min));
  // Представим, что тут не просто генерация случайного числа,
  // а какая-нибудь асинхронная операция, например получение
  // данных с сервера. Если сервер ответил, возвращаем данные;
  // если какая-то ошибка, то возвращаем ошибку
  if (rand > 5) {
    resolve('Успех');
  } else {
    reject('Неудача');
  };
})
  .finally(() => console.log('Промис завершился'))
  .then(data => console.log(data))
  .catch(error => console.log(error));
```

Код промиса начинает выполняться сразу же, как только создан объект. Объект имеет несколько свойств:

* `state` - до получения результата имеет значение *pending*. После вызова resolve становится *fullfilled*, а после reject - *rejected*
* `result` - изначально *undefined*, а после вызова resolve или reject его значением становится то, что было им передано

Эти свойства - внутренние, поэтому прямого доступа к ним нет. Работа с результатом ведется с помощью методов `then`, `catch` и `finally`



# then, catch, finally

► `then` - универсальный метод обработки. Он может принять разом и колбэк успеха, и колбэк провала:

```javascript
promise.then(
  data => successHandler(data),
  error => failureHandler(error)
);
```

Можно не передавать второй параметр, если не нужно обрабатывать ошибку. Можно передать null и колбэк провала, если наоборот - обрабатывать результат не надо, а ошибку надо.

Однако для удобства обычно в then передают только колбэк успеха, а колбэк провала передают в catch

► `catch` - принимает колбэк провала:

```javascript
promise.catch(error => failureHandler(error));
```

► `finally` - этот метод принимает колбэк, содержащий действия, которые должны выполниться в любом случае, независимо от статуса промиса. Например, какие-нибудь действия по очистке чего-либо (по аналогии с try-catch-finally в случае отлова исключений). Поэтому, раз уж ему безразлично, успешно ли выполнился промис или нет, колбэк в finally не имеет никаких параметров.

Несмотря на то, что описан finally в конце, к самому промису он подключается самым первым, потому что он должен пробрасывать результат дальше - в then или catch:

```javascript
promise
  .finally(() => cleanupHandler())
  .then(data => successHandler(data))
  .catch(error => failureHandler(error));
```

► Не обязательно сначала сохранять промис в переменную, чтобы применять эти методы. Можно делать вот так:

```javascript
new Promise((resolve, reject) => {
  setTimeout(() => resolve("result"), 2000)
})
  .finally(() => console.log("Промис завершён"))
  .then(result => console.log(result));
```



# Цепочка обработчиков

► Обработчики можно соединять в цепочки, чтобы каждый следующий получал результат работы предыдущего:

```javascript
promise
  .then(...)
  .then(...)
  .then(...);
```

```javascript
new Promise(function(resolve, reject) {
  let value = 1;
  console.log(`Сначала value было ${value}`);
  resolve(value);
})
  .then(value => {
    value *= 2;
    console.log(`После первой обработки стало ${value}`);
    return value;
  })
  .then(value => {
    value *= 2;
    console.log(`После второй ${value}`);
    return value;
  })
  .then(value => {
    value *= 2;
    console.log(`Ну а после третьей ${value}`);
    return value;
  });

// Сначала value было 1
// После первой обработки стало 2
// После второй стало 4
// Ну а после третьей 8
```

► Однако следующая запись не является цепочкой:

```javascript
promise.then(...);
promise.then(...);
promise.then(...);
```

```javascript
let promise = new Promise(function(resolve, reject) {
  let value = 1;
  console.log(`Сначала value было ${value}`);
  resolve(value);
});

promise.then(value => {
  value *= 2;
  console.log(`После первой обработки стало ${value}`);
  return value;
});

promise.then(value => {
  value *= 2;
  console.log(`После второй ${value}`);
  return value;
});

promise.then(value => {
  value *= 2;
  console.log(`Ну а после третьей ${value}`);
  return value;
});

// Сначала value было 1
// После первой обработки стало 2
// После второй 2
// Ну а после третьей 2
```

Все потому что каждый обработчик прицеплен к самому промису, а не к предыдущему обработчику. Поэтому каждый из них получает результат работы промиса - то есть 1.

# Синхронизация асинхронных обработчиков

В предыдущем примере с цепочкой промисов не было асинхронного кода. Все обработчики выполнились по очереди, исправно передавая результаты своей работы дальше по цепочке.

Добавим асинхронности с помощью setTimeout():

```javascript
new Promise(function(resolve, reject) {
  console.log('Промис стартовал в ' + currentTime());
  setTimeout(() => {
    let value = 1;
    console.log(currentTime() + ' ' + value);
    resolve(value);
  }, 2000);
})
  .then(result => {
    console.log('Первый обработчик вызван в ' + currentTime());
    setTimeout(() => {
      result *= 2;
      console.log(currentTime() + ' результат первого ' + result);
      return result;
    }, 4000);
  })
  .then(result => {
    console.log('Второй обработчик вызван в ' + currentTime());
    setTimeout(() => {
      result *= 2;
      console.log(currentTime() + ' результат второго ' + result);
      return result;
    }, 3000);
  })
  .then(result => {
    console.log('Третий обработчик вызван в ' + currentTime());
    setTimeout(() => {
      result *= 2;
      console.log(currentTime() + ' результат третьего ' + result);
    }, 2000);
  });

// Промис стартовал в 19:07:10
// 19:07:12 1
// Первый обработчик вызван в 19:07:12
// Второй обработчик вызван в 19:07:12
// Третий обработчик вызван в 19:07:12
// 19:07:14 результат третьего NaN
// 19:07:15 результат второго NaN
// 19:07:16 результат первого 2
```

Как видно, обработчики вызвались в правильном порядке и вызов произошел почти моментально. Однако расчет и возврат результата был специально искусственно задержан, чтобы показать две вещи. Во-первых, заход в обработчик и получение результата его работы - не одно и то же и могут находиться далеко друг от друга во времени. Во-вторых, порядок получения результатов при наличии асинхронных операций не зависит от порядка следования обработчиков - в примере первый результат пришел от третьего обработчика, а первый обработчик вернул результат последним.

Таким образом, только первый обработчик получил исходные данные, потому что они вернулись из завершившегося промиса. Второй обработчик получил на вход undefined, поскольку первый не успел к этому моменту выполнить расчет из-за искуственной задержки и передать его дальше. То же самое произошло с третьим обработчиком - он получил undefined, потому что второй не выполнил свою работу.

► Чтобы синхронизировать обработчики, содержащие асинхронные операции и заставить их ждать друг друга, из них тоже нужно возвращать промисы:

```javascript
new Promise(function(resolve, reject) {
  console.log('Промис стартовал в ' + currentTime());
  setTimeout(() => {
    let value = 1;
    console.log(currentTime() + ' ' + value);
    resolve(value);
  }, 2000);
})
  .then(result => {
    console.log('Первый обработчик вызван в ' + currentTime());
    return new Promise(function(resolve, reject) {
      setTimeout(() => {
        result *= 2;
        console.log(currentTime() + ' результат первого ' + result);
        resolve(result);
      }, 4000);
    });
  })
  .then(result => {
    console.log('Второй обработчик вызван в ' + currentTime());
    return new Promise(function(resolve, reject) {
      setTimeout(() => {
        result *= 2;
        console.log(currentTime() + ' результат второго ' + result);
        resolve(result);
      }, 3000);
    });
  })
  .then(result => {
    console.log('Третий обработчик вызван в ' + currentTime());
    setTimeout(() => {
      result *= 2;
      console.log(currentTime() + ' результат третьего ' + result);
    }, 2000);
  });

// Промис стартовал в 19:33:44
// 19:33:46 1
// Первый обработчик вызван в 19:33:46
// 19:33:50 результат первого 2
// Второй обработчик вызван в 19:33:50
// 19:33:53 результат второго 4
// Третий обработчик вызван в 19:33:53
// 19:33:55 результат третьего 8
```

> Правда я тут не понял как это работает технически. Может быть, then анализирует тип приходящего в него значения и если это промис, то он ждет выполнения и забирает результат. А может быть еще как-то. В любом случае, на вид это довольно сложно, поэтому я пока просто запомню, а если понадобится знать как это реализовано, разберусь позже.