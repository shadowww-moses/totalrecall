Массивы - это подвид объектов, предназначенный для хранения *упорядоченной* коллекции данных. У массивов есть специальные методы, характерные только для них. Движок применяет специальные оптимизации для массивов, поэтому, чтобы не потерять эти преимущества, с массивами нужно обращаться правильно. Поскольку массивы это объекты, то работа с ними везде тоже осуществляется по ссылке.

Массивы также выполняют в Javascript роль таких структур данных как *стек* и *очередь*.

# Общая информация

► Объявить массив можно двумя способами:

```javascript
let arr = new Array();  // редко используется
let arr = new Array(2); // массив из двух undefined элементов
let arr = [];
```

► Можно проинициализировать массив при создании:

```javascript
let arr = ['Яблоко', 'Апельсин', 'Груша'];
let arr = new Array('Яблоко', 'Апельсин', 'Груша');
```

► Доступ к элементам возможен по индексу:

```javascript
console.log(arr[0]);  // Яблоко
console.log(arr[1]);  // Апельсин

arr[2] = 'Абрикос';
console.log(arr[2]);  // Абрикос
```

► В массиве могут лежать совершенно разные данные:

```javascript
let arr = [
  'Яблоко',
  { name: 'Alice' },
  function() { console.log('Функция, лежащая в массиве') },
  5,  // Висячая запятая по желанию
];

console.log(arr[2].name);  // Alice
arr[3]();  // Функция, лежащая в массиве
```



## Размер массива

► Размер массива находится в свойстве `length`:

```javascript
let arr = ['Яблоко', 'Груша', 'Апельсин'];
console.log(arr.length);  // 3, вроде все правильно
```

```javascript
let arr = [];

arr[2] = 'Яблоко';

console.log(arr[2]);  // Яблоко
console.log(arr.length);  // 3, хотя элемент один и хранится под индексом 2
```

То есть `length` на самом деле - это максимальный числовой индекс + 1. В случае правильного использования массива это не приводит к проблемам.

► Чтобы использовать массивы правильно, нельзя делать следующее:

* Добавлять в массив нечисловые свойства `arr.comment = "Hello, world!"`

* Создавать дыры, как было показано выше

  ```javascript
  let arr = ['Яблоко', 'Груша', 'Апельсин'];
  arr[8] = 'Ананас';
  console.log(arr);  // Array(9) [ "Яблоко", "Груша", "Апельсин", <5 empty slots>, "Ананас" ]
  console.log(arr.length);  // 9
  console.log(arr[7]);  // undefined
  ```

* Заполнять массив в обратном порядке `arr[5] = 'Hello'; arr[4] = 'world';`

При нарушении любого из этих условий движок начинает воспринимать массив как обычный объект и прекращает применять к нему оптимизации. Поэтому добавлять, удалять элементы следует с помощью специальных методов `push/pop` и `shift/unshift`

> Еще одно наблюдение насчет индексов:
>
> ```javascript
> let arr = [];
> 
> arr[-5] = 'Яблоко';
> arr[-3] = 'Груша';
> 
> console.log(arr[-5]);  // Яблоко
> console.log(arr.length);  // 0, отрицательные числа в индексах lengh игнорирует
> 
> arr[6] = 'Слива';
> console.log(arr.length);  // 7, но когда появляется положительное, работает
> ```

► Ручное уменьшение `length` позволяет безвозвратно удалить элементы:

```javascript
let arr = [1, 2, 3, 4, 5];

arr.length = 2; // укорачиваем до двух элементов
alert(arr); // [1, 2]

arr.length = 5; // возвращаем length как было
alert( arr[3] ); // undefined: значения не восстановились
```

Таким образом, самый быстрый способ очистить массив, это `arr.length = 0`

## Добавление, извлечение

### push/pop

Эта пара методов работает с концом массива. Они работают быстро, поскольку не требуют перемещений других элементов:

```javascript
let arr = ['Яблоко', 'Груша', 'Апельсин'];
console.log(arr); // Array(3) [ "Яблоко", "Груша", "Апельсин" ]

arr.push('Ананас');
console.log(arr);  // Array(4) [ "Яблоко", "Груша", "Апельсин", "Ананас" ]

let item = arr.pop();  // Ананас
console.log(item); //
console.log(arr); // Array(3) [ "Яблоко", "Груша", "Апельсин" ]
```

`push` добавляет элемент в конец массива, а `pop` возвращает последний элемент, при этом удаляя его из массива.

### shift/unshift

Эта пара работает с началом массива. Они работают медленнее, потому что сопровождаются перемещением всех элементов:

```javascript
let arr = ['Яблоко', 'Груша', 'Апельсин'];

arr.unshift('Ананас');
console.log(arr); // Array(4) [ "Ананас", "Яблоко", "Груша", "Апельсин" ]

let item = arr.shift();
console.log(item);  // Ананас
console.log(arr);  // Array(3) [ "Яблоко", "Груша", "Апельсин" ]
```

`shift` - возвращает элемент из начала и удаляет его из массива, таким образом как бы "сдвигая" его влево. А `unshift` - добавляет в начало.



## Обход

► Можно обойти массив, используя индексы:

```javascript
let arr = ["Яблоко", "Апельсин", "Груша"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}
```

► Или воспользоваться специальным синтаксисом `for of`:

```javascript
let fruits = ["Яблоко", "Апельсин", "Слива"];

for (let f of fruits) {
  console.log(f);
}
```

> Еще можно обойти через `for in`, но для массивов это плохо подходит потому что, во-первых, этот цикл предназначен для объектов в общем и не оптимизирован для массивов конкретно, поэтому работает в 10-100 раз медленнее, чем `for of`. Во-вторых, он предназначен для вывода *всех* свойств, а не только числовых.
>
> Эксперименты: 
>
> 1. Берем правильный массив и обходим через `for in`:
>
>    ```javascript
>    let fruits = ['Яблоко', 'Груша'];
>    
>    for (let key in fruits) {
>      console.log(fruits[key]);
>    }
>    // Яблоко, груша
>    ```
>
>    `length` не вывелось
>
> 2. "Портим" массив и обходим снова:
>
>    ```javascript
>    let fruits = ['Яблоко', 'Груша'];
>    fruits['comment'] = "Wrong usage";
>    
>    for (let key in fruits) {
>      console.log(fruits[key]);
>    }
>    // Яблоко, груша, Wrong usage
>    ```
>
>    Произвольное свойство вывелось
>
> 3. "Испорченный" массив обходим через `for of`:
>
>    ```javascript
>    let fruits = ['Яблоко', 'Груша'];
>    fruits['comment'] = "Wrong usage";
>    
>    for (let f of fruits) {
>      console.log(f);
>    }
>    // Яблоко, груша
>    ```
>
>    Он обошел только числовые свойства

► У массивов есть метод `forEach(function(value, index, array))`. Он принимает функцию и выполняет ее для каждого элемента. Эта функция получает через свои параметры доступ к значению элемента, его индексу и самой переменной массива. Если эта функция возвращает какое-то значение, оно отбрасывается. 

```javascript
let fruits = ['Яблоки', 'Груши', 'Апельсины'];

fruits.forEach((value, index, arrVariable) => {
  console.log(`${value} at [${index}] in ${arrVariable}`);
});
// Яблоки at [0] in Яблоки,Груши,Апельсины
// Груши at [1] in Яблоки,Груши,Апельсины
// Апельсины at [2] in Яблоки,Груши,Апельсины
```

Эта функция может модифицировать элементы массива:

```javascript
fruits.forEach((value, index, arrVariable) => {
  arrVariable[index] += '!!!';
});
console.log(fruits);  // Array(3) [ "Яблоки!!!", "Груши!!!", "Апельсины!!!" ]
```

Не обязательно писать все параметры:

```javascript
fruits.forEach(item => console.log(item));
```



## Многомерные массивы

```javascript
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

console.log(matrix[1][1]);
```



## Массив или не массив?

Поскольку массив - не самостоятельный тип, а подвид объектов, оператор typeof их не отличает:

```javascript
typeof {}; // object
typeof []; // тоже object
```

и нужно пользоваться методом `Array.isArray()`:

```javascript
Array.isArray({}); // false
Array.isArray([]); // true
```





# Манипуляции с массивами

## splice

► Модифицирующий метод. Позволяет удалять элементы из массива, заменять, добавлять:

```javascript
arr.splice(index[, deleteCount, elem1, ..., elemN])
```

`index` - с какого элемента начинать. Возможны отрицательные индексы для отсчета с конца

`deleteCount` - сколько удалять, 

`elem1... elemN` - добавляемые элементы

► Примеры (предполагается, что каждый пример модифицирует исходный массив):

```javascript
let phrase = ['Я', 'изучаю', 'Javascript'];
console.log(phrase);  // Array(3) [ "Я", "изучаю", "Javascript" ]
```

Добавим одно слово после первого элемента:

```javascript
phrase.splice(1, 0, 'подробно');
// Array(4) [ "Я", "подробно", "изучаю", "Javascript" ]
```

Добавим несколько слов в конец:

```javascript
phrase.splice(phrase.length, 0, 'и', 'не', 'только');
// Array(6) [ "Я", "изучаю", "Javascript", "и", "не", "только" ]
```

Заменим последнее слово на другое (т.е. удалим + добавим). Для этого воспользуемся отрицательным индексом, чтобы вести отчет с конца. При этом есть возможность сохранить удаленные элементы в другой массив:

```javascript
let deleted = phrase.splice(-1, 1, 'C#');
console.log(phrase);  // Array(3) [ "Я", "изучаю", "C#" ]
console.log(deleted); // Array [ "Javascript" ]
```

Удалим первое слово / два последних:

```javascript
phrase.splice(0, 1);  // Array [ "изучаю", "Javascript" ]
phrase.splice(-2, 2); // Array [ "Я" ]
```



## slice

► Немодифицирующий метод. Возвращает требуемый фрагмент массива: 

```javascript
arr.slice([start], [end])
```

 `start`  - начальный индекс

 `end` - конечный индекс, не включая сам `end`

Возможны отрицательные индексы для отсчета с конца

`end` не может быть меньше `start`, иначе вернется пустой массив

► Примеры:

```javascript
               0      1           2         3     4       5
let phrase = ['Я', 'изучаю', 'Javascript', 'и', 'не', 'только'];
```

Вызывая без параметров, просто получаем независимую копию массива:

```javascript
let clone = phrase.slice();
console.log(clone);  
// Array(6) ['Я', 'изучаю', 'Javascript', 'и', 'не', 'только'];
```

Надо быть внимательным и не перепутать - второй параметр это индекс, а не количество элементов:

```javascript
let part = phrase.slice(1, 3);  // Array [ "изучаю", "Javascript" ]
let part = phrase.slice(-3, 2);  // Array [] - косяк, 2 - это не кол-во элементов
let part = phrase.slice(-3, -2); // Array [ "и" ] а вот так нормально
```

Если не указывать второй параметр, берутся все элементы до конца:

```javascript
let part = phrase.slice(4);  // Array [ "не", "только" ]
let part = phrase.slice(-3);  // Array(3) [ "и", "не", "только" ]
```



## concat

```javascript
arr.concat(arg1, arg2...)
```

Склеивает массив `arr` с переданными аргументами. Если они массивы, то берутся все их элементы:

```javascript
let arr = [1, 2];
arr.concat([3, 4]);  // 1,2,3,4
```

Если не массивы (например, объекты), то добавляются целиком: 

```javascript
let arrayLike = {
  0: "что-то",
  length: 1
};

arr.concat(arrayLike); // 1,2,[object Object]
```

Аргументами могут быть и простые значения:

```javascript
arr.concat([3, 4], 5, 6);  // 1,2,3,4,5,6
```

Если объект имеет свойство `Symbol.isConcatSpreadable`, то из него добавляются только числовые свойства:

```javascript
let arrayLike = {
  0: "что-то",
  1: "ещё",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

arr.concat(arrayLike);  // 1,2,что-то,ещё
```

## map

Принимает функцию, обходит все элементы массива и применяет к ним эту функцию. Возвращает новый массив:

```javascript
let fruits = [
  { id: 0, name: 'Яблоки' },
  { id: 1, name: 'Груши' },
  { id: 2, name: 'Апельсины' }
];

let modified = fruits.map(item => item.name += '!!!');
```

## sort

Сортирует массив, меняя прямо в нем порядок элементов. Возвращает отсортированный массив, хотя это и не нужно, ведь исходный массив модифицируется. По умолчанию воспринимает элементы как строки:

```javascript
let arr = [ 1, 2, 15 ];
arr.sort();  // 1, 15, 2  <-- Ошибочка вышла
```

Поскольку в массиве может лежать что угодно, например, объекты, в метод sort можно передать функцию, которая определяет правило сравнения. Выглядит она примерно так:

```javascript
function compare(a, b) {
  if (a > b) return 1; // вернуть ЛЮБОЕ ПОЛОЖИТЕЛЬНОЕ значение
  if (a == b) return 0; // если равны, вернуть 0
  if (a < b) return -1; // вернуть ЛЮБОЕ ОТРИЦАТЕЛЬНОЕ
}
```

Можно передавать любые функции, поэтому стрелки хорошо подходят для краткости:

```javascript
let numbers = [2, 1, 15];
numbers.sort((a, b) => a - b);
console.log(numbers);
```

Для осуществления вычитания элементы преобразуются к числам и теперь сравнение происходит правильно.

## reverse

Меняет порядок элементов в массиве задом наперед. Тоже возвращает измененный массив, хотя это и не нужно:

```javascript
let arr = [1, 2, 3, 4, 5];
arr.reverse();  // 5, 4, 3, 2, 1
```

## reduce / reduceRight

Обходит все элементы массива и применяет к ним переданную ему функцию. Эта функция имеет четыре параметра:

```javascript
let value = arr.reduce(function(previousValue, item, index, array) {
  // ...
}, [initial]);
```

`item, index, array` - уже знакомые элемент, индекс и сама переменная с массивом

`previousValue` - reduce вычисляет значение функции на текущем шаге и передает это значение на следующий шаг через этот параметр

`initial` - начальное значение для "previousValue". Если не задано, то берется первый элемент массива. Поэтому если массив пустой, будет ошибка.

►Пример:

Хорошо понятно как это работает на примере обычного сложения чисел:

```javascript
let numbers = [2, 1, 15, 8];
let result = numbers.reduce(
  (sum, current) => sum + current,
  0
);
console.log(result);  // 26
```

`reduceRight` делает то же самое, только обходит элементы с конца до начала.



# Поиск в массиве

## indexOf / lastIndexOf / includes

Ищут по *конкретному значению*.

Все методы имеют два параметра `(needle, from)`, т.е. что и откуда. Если найдено, возвращается *позиция* элемента, если не найдено -1. В поиске используется строгое сравнение ===

```javascript
let arr = [1, 0, false];

arr.indexOf(0);  // 1
arr.indexOf(false);  // 2
arr.indexOf(null);  // -1

arr.includes(1);  // true
```

`includes` правильно обрабатывает `NaN`, а другие методы его не видят:

```javascript
const arr = [NaN];
arr.indexOf(NaN);  // -1, не нашел
arr.includes(NaN);  // true, увидел
```

► **lastIndexOf** ищет справа налево:

```javascript
let arr = [ 0, 1, 2, 3, 4 , 5];
console.log(arr.lastIndexOf(4, 5));  // 4
console.log(arr.lastIndexOf(4, 3));  // -1
```

В этом примере элементы специально совпадают со своими индексами, чтобы проще видеть закономерность. В первом случае from=5 и поэтому значение 4 нашлось. Во втором случае поиск начинается от индекса 3 и идет влево, поэтому значение 4 не попадает в область поиска и не находится.

## find / findIndex / filter

Ищут *по условию*, а не по *конкретному значению*. Все они принимают функцию, которая получает через свои параметры элемент, его индекс и переменную массива. Происходит обход элементов и функция применяется к каждому из них. 

```javascript
let result = arr.find(function(item, index, array) { 
  // код функции
});
```

► Примеры:

```javascript
let fruits = [
  { id: 0, name: 'Яблоки' },
  { id: 1, name: 'Груши' },
  { id: 2, name: 'Апельсины' }
];
```

► **find** - возвращает *первый* элемент, подошедший под условие:

```javascript
// Не обязательно указывать все параметры, обычно используется только сам элемент
let f = fruits.find(item => item.name == 'Груши');
console.log(f);  // Object { id: 1, name: "Груши" }
```

Если ни один элемент не подходит, возвращает undefined:

```javascript
let f = fruits.find(item => item.name == 'Абрикосы');
console.log(f);  // undefined
```

Хотя под условие подходят два элемента, `find` возвращает только первый успешно прошедший проверку:

```javascript
let fs = fruits.find(
  (item, index, arr) => item.id > 0
);
console.log(fs);  // Object { id: 1, name: "Груши" }
```

► **findIndex** - то же самое, что и `find`, только возвращает *индекс* элемента или -1, если ни один элемент не подходит под условие

► **filter** - возвращает массив со всеми элементами, прошедшими условие, либо пустой массив, если ни один элемент не подошел:

```javascript
let fs = fruits.filter(
  (item, index, arr) => item.id > 0
);
console.log(fs);  // Array [ {…}, {…} ] - вернул массив в двумя объектами
// 0: Object { id: 1, name: "Груши" }
// 1: Object { id: 2, name: "Апельсины" }
```



# Дополнительно

### toString

Метод `toString` для массива возвращает список элементов, разделённых запятыми.

```javascript
let arr = [1, 2, 3];

alert(arr);  // 1,2,3
alert(String(arr) === '1,2,3');  // true
```

Массивы не имеют ни `Symbol.toPrimitive`, ни функционирующего `valueOf`, они реализуют только преобразование `toString`.  `[]` становится пустой строкой, `[1]` становится `"1"`, а `[1,2]` становится `"1,2"`:

```javascript
alert( [] + 1 );  // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
```

### thisArg

Почти все методы массива, которые вызывают функции – такие как `find`, `filter`, `map`, за исключением метода `sort`, принимают необязательный параметр `thisArg`.

Этот параметр не объяснялся выше, так как очень редко используется,  но для наиболее полного понимания темы мы обязаны его рассмотреть.

Вот полный синтаксис этих методов:

```javascript
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg - это необязательный последний аргумент
```

Значение параметра `thisArg` становится `this` для `func`.

Например, вот тут мы используем метод объекта `army` как фильтр, и `thisArg` передаёт ему контекст:      

```javascript
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// найти пользователей, для которых army.canJoin возвращает true
let soldiers = users.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
```

Если бы мы в примере выше использовали просто `users.filter(army.canJoin)`, то вызов `army.canJoin` был бы в режиме отдельной функции, с `this=undefined`. Это тут же привело бы к ошибке.

Вызов `users.filter(army.canJoin, army)` можно заменить на `users.filter(user => army.canJoin(user))`, который делает то же самое. Последняя запись используется даже чаще, так как функция-стрелка более наглядна.