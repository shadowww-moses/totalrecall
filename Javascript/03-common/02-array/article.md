Массивы - это подвид объектов, предназначенный для хранения *упорядоченной* коллекции данных. У массивов есть специальные методы, характерные только для них. Движок применяет специальные оптимизации для массивов, поэтому, чтобы не потерять эти преимущества, с массивами нужно обращаться правильно. Поскольку массивы это объекты, то работа с ними везде тоже осуществляется по ссылке.

Массивы также выполняют в Javascript роль таких структур данных как *стек* и *очередь*.

# Общая информация

► Объявить массив можно двумя способами:

```javascript
let arr = new Array();  // редко используется
let arr = new Array(2); // массив из двух undefined элементов
let arr = [];
```

► Можно проинициализировать массив при создании:

```javascript
let arr = ['Яблоко', 'Апельсин', 'Груша'];
let arr = new Array('Яблоко', 'Апельсин', 'Груша');
```

► Доступ к элементам возможен по индексу:

```javascript
console.log(arr[0]);  // Яблоко
console.log(arr[1]);  // Апельсин

arr[2] = 'Абрикос';
console.log(arr[2]);  // Абрикос
```

► В массиве могут лежать совершенно разные данные:

```javascript
let arr = [
  'Яблоко',
  { name: 'Alice' },
  function() { console.log('Функция, лежащая в массиве') },
  5,  // Висячая запятая по желанию
];

console.log(arr[2].name);  // Alice
arr[3]();  // Функция, лежащая в массиве
```



## Размер массива

► Размер массива находится в свойстве `length`:

```javascript
let arr = ['Яблоко', 'Груша', 'Апельсин'];
console.log(arr.length);  // 3, вроде все правильно
```

```javascript
let arr = [];

arr[2] = 'Яблоко';

console.log(arr[2]);  // Яблоко
console.log(arr.length);  // 3, хотя элемент один и хранится под индексом 2
```

То есть `length` на самом деле - это максимальный числовой индекс + 1. В случае правильного использования массива это не приводит к проблемам.

► Чтобы использовать массивы правильно, нельзя делать следующее:

* Добавлять в массив нечисловые свойства `arr.comment = "Hello, world!"`

* Создавать дыры, как было показано выше

  ```javascript
  let arr = ['Яблоко', 'Груша', 'Апельсин'];
  arr[8] = 'Ананас';
  console.log(arr);  // Array(9) [ "Яблоко", "Груша", "Апельсин", <5 empty slots>, "Ананас" ]
  console.log(arr.length);  // 9
  console.log(arr[7]);  // undefined
  ```

* Заполнять массив в обратном порядке `arr[5] = 'Hello'; arr[4] = 'world';`

При нарушении любого из этих условий движок начинает воспринимать массив как обычный объект и прекращает применять к нему оптимизации. Поэтому добавлять, удалять элементы следует с помощью специальных методов `push/pop` и `shift/unshift`

> Еще одно наблюдение насчет индексов:
>
> ```javascript
> let arr = [];
> 
> arr[-5] = 'Яблоко';
> arr[-3] = 'Груша';
> 
> console.log(arr[-5]);  // Яблоко
> console.log(arr.length);  // 0, отрицательные числа в индексах lengh игнорирует
> 
> arr[6] = 'Слива';
> console.log(arr.length);  // 7, но когда появляется положительное, работает
> ```

► Ручное уменьшение `length` позволяет безвозвратно удалить элементы:

```javascript
let arr = [1, 2, 3, 4, 5];

arr.length = 2; // укорачиваем до двух элементов
alert(arr); // [1, 2]

arr.length = 5; // возвращаем length как было
alert( arr[3] ); // undefined: значения не восстановились
```

Таким образом, самый быстрый способ очистить массив, это `arr.length = 0`

## Добавление, извлечение

### push/pop

Эта пара методов работает с концом массива. Они работают быстро, поскольку не требуют перемещений других элементов:

```javascript
let arr = ['Яблоко', 'Груша', 'Апельсин'];
console.log(arr); // Array(3) [ "Яблоко", "Груша", "Апельсин" ]

arr.push('Ананас');
console.log(arr);  // Array(4) [ "Яблоко", "Груша", "Апельсин", "Ананас" ]

let item = arr.pop();  // Ананас
console.log(item); //
console.log(arr); // Array(3) [ "Яблоко", "Груша", "Апельсин" ]
```

`push` добавляет элемент в конец массива, а `pop` возвращает последний элемент, при этом удаляя его из массива.

### shift/unshift

Эта пара работает с началом массива. Они работают медленнее, потому что сопровождаются перемещением всех элементов:

```javascript
let arr = ['Яблоко', 'Груша', 'Апельсин'];

arr.unshift('Ананас');
console.log(arr); // Array(4) [ "Ананас", "Яблоко", "Груша", "Апельсин" ]

let item = arr.shift();
console.log(item);  // Ананас
console.log(arr);  // Array(3) [ "Яблоко", "Груша", "Апельсин" ]
```

`shift` - возвращает элемент из начала и удаляет его из массива, таким образом как бы "сдвигая" его влево. А `unshift` - добавляет в начало.



## Обход

► Можно обойти массив, используя индексы:

```javascript
let arr = ["Яблоко", "Апельсин", "Груша"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}
```

► Или воспользоваться специальным синтаксисом `for of`:

```javascript
let fruits = ["Яблоко", "Апельсин", "Слива"];

for (let f of fruits) {
  console.log(f);
}
```

> Еще можно обойти через `for in`, но для массивов это плохо подходит потому что, во-первых, этот цикл предназначен для объектов в общем и не оптимизирован для массивов конкретно, поэтому работает в 10-100 раз медленнее, чем `for of`. Во-вторых, он предназначен для вывода *всех* свойств, а не только числовых.
>
> Эксперименты: 
>
> 1. Берем правильный массив и обходим через `for in`:
>
>    ```javascript
>    let fruits = ['Яблоко', 'Груша'];
>    
>    for (let key in fruits) {
>      console.log(fruits[key]);
>    }
>    // Яблоко, груша
>    ```
>
>    `length` не вывелось
>
> 2. "Портим" массив и обходим снова:
>
>    ```javascript
>    let fruits = ['Яблоко', 'Груша'];
>    fruits['comment'] = "Wrong usage";
>    
>    for (let key in fruits) {
>      console.log(fruits[key]);
>    }
>    // Яблоко, груша, Wrong usage
>    ```
>
>    Произвольное свойство вывелось
>
> 3. "Испорченный" массив обходим через `for of`:
>
>    ```javascript
>    let fruits = ['Яблоко', 'Груша'];
>    fruits['comment'] = "Wrong usage";
>    
>    for (let f of fruits) {
>      console.log(f);
>    }
>    // Яблоко, груша
>    ```
>
>    Он обошел только числовые свойства



## Многомерные массивы

```javascript
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

console.log(matrix[1][1]);
```



## Дополнительно

### toString

Метод `toString` для массива возвращает список элементов, разделённых запятыми.

```javascript
let arr = [1, 2, 3];

alert(arr);  // 1,2,3
alert(String(arr) === '1,2,3');  // true
```

Массивы не имеют ни `Symbol.toPrimitive`, ни функционирующего `valueOf`, они реализуют только преобразование `toString`.  `[]` становится пустой строкой, `[1]` становится `"1"`, а `[1,2]` становится `"1,2"`:

```javascript
alert( [] + 1 );  // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
```



# Методы массивов

## splice

► Модифицирующий метод. Позволяет удалять элементы из массива, заменять, добавлять:

```javascript
arr.splice(index[, deleteCount, elem1, ..., elemN])
```

`index` - с какого элемента начинать. Возможны отрицательные индексы для отсчета с конца

`deleteCount` - сколько удалять, 

`elem1... elemN` - добавляемые элементы

► Примеры (предполагается, что каждый пример модифицирует исходный массив):

```javascript
let phrase = ['Я', 'изучаю', 'Javascript'];
console.log(phrase);  // Array(3) [ "Я", "изучаю", "Javascript" ]
```

Добавим одно слово после первого элемента:

```javascript
phrase.splice(1, 0, 'подробно');
// Array(4) [ "Я", "подробно", "изучаю", "Javascript" ]
```

Добавим несколько слов в конец:

```javascript
phrase.splice(phrase.length, 0, 'и', 'не', 'только');
// Array(6) [ "Я", "изучаю", "Javascript", "и", "не", "только" ]
```

Заменим последнее слово на другое (т.е. удалим + добавим). Для этого воспользуемся отрицательным индексом, чтобы вести отчет с конца. При этом есть возможность сохранить удаленные элементы в другой массив:

```javascript
let deleted = phrase.splice(-1, 1, 'C#');
console.log(phrase);  // Array(3) [ "Я", "изучаю", "C#" ]
console.log(deleted); // Array [ "Javascript" ]
```

Удалим первое слово / два последних:

```javascript
phrase.splice(0, 1);  // Array [ "изучаю", "Javascript" ]
phrase.splice(-2, 2); // Array [ "Я" ]
```



## slice

► Немодифицирующий метод. Возвращает требуемый фрагмент массива: 

```javascript
arr.slice([start], [end])
```

 `start`  - начальный индекс

 `end` - конечный индекс, не включая сам `end`

Возможны отрицательные индексы для отсчета с конца

`end` не может быть меньше `start`, иначе вернется пустой массив

► Примеры:

```javascript
               0      1           2         3     4       5
let phrase = ['Я', 'изучаю', 'Javascript', 'и', 'не', 'только'];
```

Вызывая без параметров, просто получаем независимую копию массива:

```javascript
let clone = phrase.slice();
console.log(clone);  
// Array(6) ['Я', 'изучаю', 'Javascript', 'и', 'не', 'только'];
```

Надо быть внимательным и не перепутать - второй параметр это индекс, а не количество элементов:

```javascript
let part = phrase.slice(1, 3);  // Array [ "изучаю", "Javascript" ]
let part = phrase.slice(-3, 2);  // Array [] - косяк, 2 - это не кол-во элементов
let part = phrase.slice(-3, -2); // Array [ "и" ] а вот так нормально
```

Если не указывать второй параметр, берутся все элементы до конца:

```javascript
let part = phrase.slice(4);  // Array [ "не", "только" ]
let part = phrase.slice(-3);  // Array(3) [ "и", "не", "только" ]
```



